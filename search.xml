<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GitHub 443 Timed out的解决方法</title>
    <url>/archives/4dcde7a2.html</url>
    <content><![CDATA[<h1 id="GitHub-443-Timed-out解决办法"><a href="#GitHub-443-Timed-out解决办法" class="headerlink" title="GitHub 443 Timed out解决办法"></a>GitHub 443 Timed out解决办法</h1><h2 id="Failed-to-connect-to-github-com-port-443-after-21090-ms-Timed-out"><a href="#Failed-to-connect-to-github-com-port-443-after-21090-ms-Timed-out" class="headerlink" title="Failed to connect to github.com port 443 after 21090 ms: Timed out"></a>Failed to connect to github.com port 443 after 21090 ms: Timed out</h2><p>最近尝试过很多方法都无法解决GitHub的上传问题，包括取消全局代理也无效。</p>
<p>取消全局代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<p>无奈之下只能选择修改hosts文件。</p>
<p>登录以下三个网站获取对应的ip地址，写入hosts文件即可。</p>
<p><a href="https://ipaddress.com/website/github.com">GitHub IP地址</a></p>
<p><img src="https://pic3.zhimg.com/80/v2-7a0b82ecaa96fdc3efda9e4295ab1eee_720w.jpg" alt="GitHub IP地址"></p>
<p><a href="https://ipaddress.com/website/github.global.ssl.fastly.net#ipinfo">github.global.ssl.Fastly.net IP地址</a></p>
<p><img src="https://pic2.zhimg.com/80/v2-aed12d6e1e2bedebba9e1444bbdc83dd_720w.jpg" alt="github.global.ssl.Fastly.net IP地址"></p>
<p><a href="https://ipaddress.com/website/assets-cdn.github.com">assets-cdn.Github.com IP地址</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-05f981b555f81338eb2bb15b5ebb5338_720w.jpg" alt="assets-cdn.Github.com IP地址"></p>
<p>如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">140.82.112.4 http://GitHub.com</span><br><span class="line"></span><br><span class="line">199.232.69.194 http://github.global.ssl.Fastly.net</span><br><span class="line"></span><br><span class="line">185.199.108.153 http://assets-cdn.Github.com</span><br><span class="line"></span><br><span class="line">185.199.109.153 http://assets-cdn.Github.com</span><br><span class="line"></span><br><span class="line">185.199.110.153 http://assets-cdn.Github.com</span><br><span class="line"></span><br><span class="line">185.199.111.153 http://assets-cdn.Github.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实测有效</p>
<p><img src="https://pic3.zhimg.com/80/v2-8ed6c75a78b8c4418f8b802d5ae38a26_720w.jpg"></p>
]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/archives/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>单片机和嵌入式系统的区别</title>
    <url>/archives/cc4d518f.html</url>
    <content><![CDATA[<h1 id="单片机和嵌入式系统的区别"><a href="#单片机和嵌入式系统的区别" class="headerlink" title="单片机和嵌入式系统的区别"></a>单片机和嵌入式系统的区别</h1><p>嵌入式和单片机并不是一对相对的概念，嵌入式系统包括硬件和软件部分，而单片机是单片微型计算机(Single Chip Microcomputer )的简称，即微控制单元(Microcontroller Unit；MCU) 。单片机可以是嵌入式系统的组成部分。我们可以理解为嵌入式系统是一个大类，单片机是其中一个重要的子类。</p>
<h1 id="什么是单片机？"><a href="#什么是单片机？" class="headerlink" title="什么是单片机？"></a>什么是单片机？</h1><p>单片机又称单片微控制器，它是将电子计算机的基本环节,如:中央处理器(又称中央处理器,主要由运算器,控制器组成),存储器,总线,输入输出接口等,采用集成电路技术集成在一片硅基片上.由于单片计算机体积很小(仅手指般大小),功能强(具有一个简单计算机的功能)。</p>
<h1 id="什么是嵌入式系统？"><a href="#什么是嵌入式系统？" class="headerlink" title="什么是嵌入式系统？"></a>什么是嵌入式系统？</h1><p>嵌入式系统是基于微处理器的计算机硬件系统，其软件设计用于执行专用功能，既可以作为独立系统，也可以作为大型系统的一部分。其核心是一个集成电路，旨在为实时操作执行计算。其软件内容只包括软件运行环境及其操作系统。硬件内容包括信号处理器、存储器、通信模块等在内的多方面的内容。</p>
<p>复杂性从单个微控制器到具有连接外围设备和网络的一套处理器；从无用户界面到复杂的图形用户界面。嵌入式系统的复杂性因设计任务而异。</p>
<p>嵌入式系统应用范围从数字手表和微波到混合动力汽车和航空电子设备。多达 98% 的制造的微处理器用于嵌入式系统。</p>
<p>嵌入式系统如何工作？</p>
<p>嵌入式系统由微控制器或数字信号处理器 (DSP)、专用集成电路 (ASIC)、现场可编程门阵列 (FPGA)、GPU 技术和门阵列管理。这些处理系统与专用于处理电气和&#x2F;或机械接口的组件集成在一起。</p>
<p>嵌入式系统编程指令，称为固件，存储在只读存储器或闪存芯片中，以有限的计算机硬件资源运行。嵌入式系统通过外围设备与外部世界连接，连接输入和输出设备。</p>
<p>嵌入式系统的基本结构</p>
<p><img src="https://pic3.zhimg.com/80/v2-510f561d07185b9ac8ce873cfa42d79e_720w.jpg" alt="嵌入式系统的基本结构"><br>嵌入式系统的基本结构包括以下组件：</p>
<p>传感器：传感器测量物理量并将其转换为电信号，然后可以由嵌入式系统工程师或任何电子仪器读取。传感器将测量的量存储到存储器中。</p>
<p>AD转换器：模数转换器将传感器发送的模拟信号转换为数字信号。<br>处理器和 ASIC：处理器评估数据以测量输出并将其存储到内存中。</p>
<p>DA 转换器：数模转换器将处理器提供的数字数据转换为模拟数据</p>
<p>执行器：执行器将 DA 转换器给出的输出与存储的实际输出进行比较，并存储批准的输出。</p>
<p>以常见的几种嵌入式开发板和单片机为例子</p>
<p>树莓派4B：<br><img src="https://pic3.zhimg.com/80/v2-e4113649f5c864c848977651efe67fde_720w.jpg" alt="树莓派4B"><br>Broadcom BCM2711, Quad core Cortex-A72 (ARM v8) 64-bit SoC @ 1.5GHz</p>
<p>Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi &#x2F; RPI) 是为学习计算机编程教育而设计)，只有信用卡大小的微型电脑，其系统基于Linux。</p>
<p>可以将树莓派理解为一台微型电脑，它与我们平时使用的电脑近乎相同。</p>
<p>Arduino：<br><img src="https://pic2.zhimg.com/80/v2-296df3f5f79f05cf00f9d1219ed160ed_720w.jpg" alt="Arduino"><br>AVR单片机、ARM芯片</p>
<p>Arduino是一款便捷灵活、方便上手的开源电子原型平台。</p>
<p>它构建于开放原始码simple I&#x2F;O介面版，并且具有使用类似Java、C语言的Processing&#x2F;Wiring开发环境。主要包含两个的部分：硬件部分是可以用来做电路连接的Arduino电路板；另外一个则是Arduino IDE，你的计算机中的程序开发环境。只要在IDE中编写程序代码，将程序上传到Arduino电路板后，程序会告诉Arduino电路板要做什么。</p>
<p>简单来说，arduino是对单片机的二次封装。</p>
<p>Stm32:<br><img src="https://pic1.zhimg.com/80/v2-66dc8e061c98669e0bf291326dbef7b4_720w.jpg" alt="stm32"><br>ARM Cortex-M内核单片机</p>
<p>stm32全称是意法半导体32位系列微控制器芯片。STM32系列专为要求高性能、低成本、低功耗的嵌入式应用设计的ARM Cortex®-M0，M0+，M3, M4和M7内核。</p>
<p>主流产品（STM32F0、STM32F1、STM32F3）、超低功耗产品（STM32L0、STM32L1、STM32L4、STM32L4+）、高性能产品（STM32F2、STM32F4、STM32F7、STM32H7）</p>
<p>51单片机：<br><img src="https://pic1.zhimg.com/80/v2-5f93514b9dbe056edf726476e000a680_720w.jpg" alt="51单片机"><br>51单片机是对兼容英特尔8051指令系统的单片机的统称</p>
<p>51单片机广泛应用于家用电器、汽车、工业测控、通信设备中。因为51单片机的指令系统、内部结构相对简单，所以国内许多高校用其进行单片机入门教学。</p>
<p>51单片机是Intel在1981年推出的由8031微控制器芯片改造升级的、使用CISC指令集的、冯诺依曼架构的、8位的8051微控制器。后Intel将8051微控制器的内核授权给其他芯片厂商,使得市面上广泛出现类似于8051的芯片,这种采用8051内核的芯片被简称为51。</p>
<p>从上述例子中我们能直观地看到这些开发板和单片机所使用处理器的不同，但是树莓派、Arduino、stm32和我们日常使用的手机均是使用arm架构的处理器，那么手机算单片机吗？</p>
<p>要回答这个问题，首先要简单介绍一下ARM处理器产品线。</p>
<p>ARM Cortex内核系列提供非常广泛的具有可扩展性的性能选项，设计人员有机会在多种选项中选择最适合自身应用的内核。Cortex系列组合大体上分为三种类别：</p>
<p>● Cortex-A—面向性能密集型系统的应用处理器内核</p>
<p>● Cortex-R—面向实时应用的高性能内核</p>
<p>● Cortex-M—面向各类嵌入式应用的微控制器内核</p>
<p><img src="https://pic2.zhimg.com/80/v2-f85640d3f7901185a13f066da1a9b191_720w.jpg" alt="处理器家族"><br>Cortex-A处理器为利用操作系统（例如Linux或者Android）的设备提供了一系列解决方案，这些设备被用于各类应用，从低成本手持设备到智能手机、平板电脑、机顶盒以及企业网络设备等。</p>
<p>Cortex-R实时处理器为要求可靠性、高可用性、容错功能、可维护性和实时响应的嵌入式系统提供高性能计算解决方案。在数以亿计的产品中得到验证的成熟技术提供极快的上市速度，并利用广泛的 ARM 生态系统、全球和本地语言以及全天候的支持服务，保证快速、低风险的产品开发。</p>
<p>Cortex-M系列基于ARMv7-M架构（用于Cortex-M3和Cortex-M4）构建，针对成本和功耗敏感的MCU和终端应用（如智能测量、人机接口设备、汽车和工业控制系统、大型家用电器、消费性产品和医疗器械）的混合信号设备进行过优化。</p>
<p>总结： Cortex-M 系列是MCU，也就是单片机，Cortex-R 系列处理器提供的性能比 Cortex-M 系列提供的性能高得多，而 Cortex-A 系列专用于具有复杂软件操作系统（需使用虚拟内存管理）的面向用户的应用。</p>
<p>综上所述，只有Cortex-A系列内核的芯片叫处理器。而上述的开发板和单片机只有Raspberry Pi以及我们日常使用的手机是Cortex-A系列内核的芯片。</p>
<p>单片机和嵌入式系统的结构</p>
<p>单片机： 软件 —— 硬件<br>嵌入式系统： 软件 ——操作系统——硬件</p>
<p>有无操作系统的区别</p>
<p>有操作系统可以实现多任务调度、文件系统、内存管理等复杂功能。</p>
<p>当系统中存在操作系统的时候，设备驱动变成了连接硬件和内核的桥梁。开发者调用统一的系统调用接口来访问各种设备，方便开发。提供操作方便、简单、提供友好的图形GUI和图形界面，追求易学易用。并且可以使用大量开源的软件，工具，库。</p>
<p>提供强大的网络功能，支持TCP&#x2F;IP协议及其他协议，提供TCP&#x2F;UDP&#x2F;IP&#x2F;PPP协议支持及统一的MAC访问层接口，为各种移动计算设备预留接口。可以实现远程控制。</p>
<p>拥有良好的软件移植性，嵌入式系统和具体应用有机地结合在一起，升级换代也是和具体产品同步进行，具有较长的生命周期。</p>
<p>而对于无操作系统的单片机而言，可以实现的功能相对单一。开发者必须要先了解这个硬件平台，才能进行软件编程，降低了开发效率且软件移植性差。</p>
<p>单片机的优势</p>
<p>从上文所述的种种优缺点来看，单片机对比嵌入式系统似乎一无是处，尽管嵌入式系统的性能强大且可实现功能众多，但嵌入式最大的劣势便是其高昂的价格。</p>
<p>单片机价格低廉，结构简单，使用方便，实现模块化，单片机可靠性高，可工作到10^6 ~10^7小时无故障，处理功能强，速度快。低电压，低功耗，控制功能强，环境适应能力强。</p>
]]></content>
      <tags>
        <tag>嵌入式</tag>
        <tag>单片机</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令整理</title>
    <url>/archives/aba2a9fd.html</url>
    <content><![CDATA[<p>一、 Linux 系统中的目录</p>
<p>“一切皆是文件”是 Unix&#x2F;Linux 的基本哲学之一,了解Linux的目录结构能让我们更得心应手地去使用相关命令。<br><img src="https://pic2.zhimg.com/80/v2-0b1560de453a9afb128fd8d821c965dd_720w.jpg" alt="linux文件目录"></p>
<p>目录	   评论<br>&#x2F;	根目录，万物起源。<br>&#x2F;bin	包含系统启动和运行所必须的二进制程序。<br>&#x2F;boot	包含 Linux 内核，最初的 RMA 磁盘映像（系统启动时，由驱动程序所需），和<br>启动加载程序。<br>&#x2F;boot&#x2F;grub&#x2F;grub.conf or menu.lst， 被用来配置启动加载程序。<br>&#x2F;boot&#x2F;vmlinuz，Linux 内核。<br>&#x2F;dev	这是一个包含设备结点的特殊目录。“一切都是文件”，也使用于设备。 在这个目录里，内核维护着它支持的设备。<br>&#x2F;etc	这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是可读的文本文件。<br>虽然&#x2F;etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：<br>&#x2F;etc&#x2F;crontab， 定义自动运行的任务。<br>&#x2F;etc&#x2F;fstab，包含存储设备的列表，以及与他们相关的挂载点。<br>&#x2F;etc&#x2F;passwd，包含用户帐号列表。<br>&#x2F;home	在通常的配置环境下，系统会在&#x2F;home下，给每个用户分配一个目录。普通只能 在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。<br>&#x2F;lib	包含核心系统程序所需的库文件。这些文件与 Windows 中的动态链接库相似。<br>&#x2F;lost+found	每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。除非文件系统 真正的损坏了，那么这个目录会是个空目录。<br>&#x2F;media	在现在的 Linux 系统中，&#x2F;media 目录会包含可移除媒体设备的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些设备连接到计算机之后，会自动地挂载到这个目录结点下。<br>&#x2F;mnt	在早些的 Linux 系统中，&#x2F;mnt 目录包含可移除设备的挂载点。<br>&#x2F;opt	这个&#x2F;opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。<br>&#x2F;proc	这个&#x2F;proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。<br>反而，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。<br>&#x2F;root	root 帐户的家目录。<br>&#x2F;sbin	这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。<br>&#x2F;tmp	这个&#x2F;tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置，导致系统每次<br>重新启动时，都会清空这个目录。<br>&#x2F;usr	在 Linux 系统中，&#x2F;usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。<br>&#x2F;usr&#x2F;bin	&#x2F;usr&#x2F;bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。<br>&#x2F;usr&#x2F;lib	包含由&#x2F;usr&#x2F;bin 目录中的程序所用的共享库。<br>&#x2F;usr&#x2F;local	这个&#x2F;usr&#x2F;local 目录，是非系统发行版自带，却打算让系统使用的程序的安装目录。<br>通常，由源码编译的程序会安装在&#x2F;usr&#x2F;local&#x2F;bin 目录下。新安装的 Linux 系统中，会存在这个目录， 但却是空目录，直到系统管理员放些东西到它里面。<br>&#x2F;usr&#x2F;sbin	包含许多系统管理程序。<br>&#x2F;usr&#x2F;share	&#x2F;usr&#x2F;share 目录包含许多由&#x2F;usr&#x2F;bin<br>目录中的程序使用的共享数据。 其中包括像默认的配置文件，图标，桌面背景，音频文件等等。<br>&#x2F;usr&#x2F;share&#x2F;doc	大多数安装在系统中的软件包会包含一些文档。在&#x2F;usr&#x2F;share&#x2F;doc 目录下， 我们可以找到按照软件包分类的文档。<br>&#x2F;var	除了&#x2F;tmp 和&#x2F;home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。&#x2F;var 目录是可能需要改动的文件存储的地方。各种数据库，假脱机文件， 用户邮件等等，都驻扎在这里。<br>&#x2F;var&#x2F;log	这个&#x2F;var&#x2F;log 目录包含日志文件，各种系统活动的记录。这些文件非常重要，并且<br>应该时时监测它们。其中最重要的一个文件是&#x2F;var&#x2F;log&#x2F;messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。</p>
<p>开关机命令</p>
<p>1、shutdown –h now：立刻进行关机</p>
<p>2、shutdown –r now：现在重新启动计算机</p>
<p>3、reboot：现在重新启动计算机</p>
<p>4、su -：切换用户；passwd：修改用户密码</p>
<p>5、logout：用户注销</p>
<p>二、操作文件和目录</p>
<p>命令格式：命令 -选项 参数 （选项和参数可以为空）</p>
<p>0、pwd命令<br>Linux pwd（英文全拼：print work directory） 命令用于显示工作目录。</p>
<p>执行 pwd 指令可立刻得知您目前所在的工作目录的绝对路径名称。</p>
<p>pwd [–help][–version]<br>–help 在线帮助。</p>
<p>–version 显示版本信息。</p>
<p>1、展示目录列表命令ls（list）<br>ls 命令选项<br>-a，–all</p>
<p>#列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。</p>
<p>-d，–directory</p>
<p>#通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。</p>
<p>-F，–classify</p>
<p>#这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个’&#x2F;‘字符。</p>
<p>-h，–human-readable</p>
<p>#当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。</p>
<p>-l</p>
<p>#以长格式显示结果。</p>
<p>-r，–reverse</p>
<p>#以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。</p>
<p>-S</p>
<p>#命令输出结果按照文件大小来排序。</p>
<p>-t</p>
<p>#按照修改时间来排序。</p>
<p>2、mkdir - 创建目录 、 rmdir – 删除目录和</p>
<p>touch – 创建文件</p>
<p>mkdir dir1<br>创建一个名为”dir1”的目录</p>
<p>rmdir dir1<br>删除一个名为”dir1”的目录</p>
<p>touch dir1<br>创建一个名为”dir1”的文件</p>
<p>3、cp - 复制文件和目录<br>-a, –archive</p>
<p>#复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。</p>
<p>-i, –interactive</p>
<p>#在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。</p>
<p>-r, –recursive</p>
<p>#递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。</p>
<p>-u, –update</p>
<p>#当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</p>
<p>-v, –verbose</p>
<p>#显示翔实的命令操作信息</p>
<p>4、mv - 移动和重命名文件<br>mv 选项</p>
<p>-i –interactive</p>
<p>#在重写一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认重写文件内容。</p>
<p>-u –update</p>
<p>#当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。</p>
<p>-v –verbose 当操作 mv 命令时，显示翔实的操作信息。</p>
<p>mv 实例<br>mv file1 file2</p>
<p>#移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容重写。 如果 file2 不存在，则创建 file2。 每种情况下，file1 不再存在。</p>
<p>mv -i file1 file2</p>
<p>#除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。</p>
<p>mv file1 file2 dir1</p>
<p>#移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。</p>
<p>mv dir1 dir2</p>
<p>#如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。</p>
<p>5、rm - 删除文件和目录<br>rm 选项</p>
<p>-i, –interactive</p>
<p>#在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件</p>
<p>-r, –recursive</p>
<p>#递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</p>
<p>-f, –force</p>
<p>#忽视不存在的文件，不显示提示信息。这选项颠覆了“–interactive”选项。</p>
<p>-v, –verbose</p>
<p>#在执行 rm 命令时，显示翔实的操作信息。</p>
<p>6.文件打包或解压命令tar<br>tar -zcvf dir1.tar.gz</p>
<p>#打包成tar.gz格式压缩包</p>
<p>tar zxvf dir1.tar.gz</p>
<p>#解压tar.gz格式压缩包</p>
<p>tar -jcvf dir1.tar.bz2</p>
<p>#打包成tar.bz2格式压缩包</p>
<p>tar jxvf dir1.tar.bz2</p>
<p>#解压tar.bz2格式的压缩包</p>
<p>-c 建立新的备份文件。</p>
<p>-v 显示详细的tar处理的文件信息</p>
<p>-f 要操作的文件名</p>
<p>-r 递归处理，将指定目录下的所有文件和子目录一并处理</p>
<p>zip -q -r dir1.zip</p>
<p>#压缩成zip格式</p>
<p>unzip dir1.zip</p>
<p>#解压zip格式的压缩包</p>
<p>-q 不显示指令执行过程。</p>
<p>-r 递归处理，将指定目录下的所有文件和子目录一并处理。</p>
<p>7 、cat<br>cat命令用于连接文件并打印到标准输出设备上。</p>
<p>语法：</p>
<p>cat [-AbEnTv]</p>
<p>选项与参数：</p>
<p>-A 相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</p>
<p>-b 列出行号，仅针对非空白行做行号显示，空白行不标行号！</p>
<p>-E 将结尾的断行字节 $ 显示出来；</p>
<p>-n 列印出行号，连同空白行也会有行号，与 -b 的选项不同；</p>
<p>-T 将 [tab] 按键以 ^I 显示出来；</p>
<p>-v 列出一些看不出来的特殊字符</p>
<p>8、grep</p>
<p>Linux grep 命令用于查找文件里符合条件的字符串。 Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。</p>
<p>-c 只输出匹配行的计数。</p>
<p>-I 不区分大小写。</p>
<p>-h 查询多文件时不显示文件名。</p>
<p>-l 查询多文件时只输出包含匹配字符的文件名。</p>
<p>-n 显示匹配行及 行号。</p>
<p>-s 不显示不存在或无匹配文本的错误信息。</p>
<p>-v 显示不包含匹配文本的所有行。</p>
<p>–color&#x3D;auto 可以将找到的关键词部分加上颜色的显示。</p>
<p>三、系统常用操作命令</p>
<p>网络管理：ping、ifconfig<br>服务管理命令：<br>service:<br>格式：<br>service s_name start|stop|status|restart<br>linux系统所有自带服务名称：&#x2F;etc&#x2F;init.d&#x2F;</p>
<p>常用：<br>service iptables stop关闭防火墙服务</p>
<p>service network start 启动网卡</p>
<p>service network stop 关闭网卡</p>
<p>service network restart 重启网络</p>
<p>端口管理<br>nststat:查看端口开放情况<br>-a:表示列举所有的连接、服务器监听<br>-t:列出所有tcp协议的服务<br>-u:列出所有udp协议的服务<br>-n:使用端口号来显示<br>-l:列出所有的监听<br>-p:列出所有服务的进程id（pid）<br>常用：netstat -atunlp</p>
<p>四、软件包管理命令（apt）</p>
<p>不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营：Debian的”.deb”，和红帽的”.rpm”。也有一些重要的例外，比方说 Gentoo，Slackware，和Foresight，但大多数会使用这两个基本系统中的一个。</p>
<p>包管理系统	发行版 (部分列表)</p>
<p>apt和apt-get 命令适用于 deb 包管理式的 Linux 操作系统（Debian、Ubuntu等），主要用于自动从互联网软件仓库中搜索、下载、安装、升级、卸载软件或操作系统。</p>
<p>apt 命令 取代的命令 命令的功能</p>
<p>apt install | apt-get install | 安装软件包</p>
<p>apt remove | apt-get remove | 移除软件包</p>
<p>apt purge | apt-get purge | 除软件包及配置文件</p>
<p>apt update | apt-get update | 刷新存储库索引</p>
<p>apt upgrade | apt-get upgrade | 升级所有可升级的软件包</p>
<p>apt autoremove | apt-get autoremove | 自动删除不需要的包</p>
<p>apt full-upgrade | apt-get dist-upgrade | 在升级软件包时自动处理依赖关系</p>
<p>apt search | apt-cache search | 搜索应用程序</p>
<p>apt show | apt-cache show | 显示安装细节</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>日常使用Linux系统是什么体验？</title>
    <url>/archives/a1e2b7b3.html</url>
    <content><![CDATA[<p>趁着五一小假期，我尝试了去使用Linux作为日常使用的操作系统，这个过程中也是踩了不少的坑，所以想写一篇文章分享一下。</p>
<p>我个人使用过Kail、CentOS7、Ubuntu16.04、Windows Subsystem for Linux（WSL）作为开发环境，我个人更喜欢Debian Style (.deb)包管理系统，所以最终选择了使用Ubuntu18.04 LTS，打算在开发之余日常使用，满足听音乐，写文档，看看视频等需求。</p>
<h1 id="Ubuntu的优缺点："><a href="#Ubuntu的优缺点：" class="headerlink" title="Ubuntu的优缺点："></a>Ubuntu的优缺点：</h1><p><img src="https://pic3.zhimg.com/80/v2-c394ee5ef8e79d2c1ee12b659d08ec32_720w.jpg"></p>
<h1 id="安装Flash插件"><a href="#安装Flash插件" class="headerlink" title="安装Flash插件"></a>安装Flash插件</h1><p>使用Firefox 浏览器时，B站无法播放视频，提示需要下载Flash插件；<br><img src="https://pic1.zhimg.com/80/v2-1b63342350894d7b71807cdb3e57a2fc_720w.jpg"><br>点击页面跳转后却提示现在Adobe官网已经不再提供flash下载；</p>
<p>（由于 Adobe 在 2020 年 12 月 31 日之后不再支持 Flash Player，并且从 2021 年 1 月12 日开始阻止 Flash 内容在 Flash Player 中运行，因此 Adobe 强烈建议所有用户立即卸载 Flash Player 以帮助保护其系统。）<br><img src="https://pic1.zhimg.com/v2-a372fc674dc8c7eb9ef4e9318e474dc0_r.jpg"></p>
<p>解决办法是通过终端安装flash插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install flashplugin-installer</span><br></pre></td></tr></table></figure>
<p>或者</p>
<h2 id="安装ubuntu-restricted-extras；"><a href="#安装ubuntu-restricted-extras；" class="headerlink" title="安装ubuntu-restricted-extras；"></a>安装ubuntu-restricted-extras；</h2><p>ubuntu-restricted-extras 是一个包含各种基本软件，如 Flash 插件、unrar、gstreamer、mp4、Ubuntu 中的 Chromium 浏览器的编解码器等的软件包。</p>
<p>Ubuntu提供了一个软件包来安装所有基本的媒体编解码器：ubuntu-restricted-extras。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ubuntu-restricted-extras</span><br></pre></td></tr></table></figure>

<h1 id="安装Google-Chrome："><a href="#安装Google-Chrome：" class="headerlink" title="安装Google Chrome："></a>安装Google Chrome：</h1><p>直接使用Google浏览器也可以解决上述问题。</p>
<h2 id="1-下载谷歌浏览器"><a href="#1-下载谷歌浏览器" class="headerlink" title="1.下载谷歌浏览器"></a>1.下载谷歌浏览器</h2><p>下载最新的谷歌浏览器。带wget的deb包：</p>
<p>wget <a href="https://dl.google.com/linux/direct/google-chrome_stable_current_amd64.deb">https://dl.google.com/linux/direct/google-chrome_stable_current_amd64.deb</a></p>
<h2 id="2-安装谷歌浏览器"><a href="#2-安装谷歌浏览器" class="headerlink" title="2.安装谷歌浏览器"></a>2.安装谷歌浏览器</h2><p>在Ubuntu上安装软件包需要sudo权限。确保以具有sudo权限的用户身份运行以下命令。</p>
<p>安装谷歌浏览器。通过键入以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>

<p>安装deb包：<br>下载好deb包后，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./“安装包名”</span><br></pre></td></tr></table></figure>
<p>如上文所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>

<h1 id="输入法软件："><a href="#输入法软件：" class="headerlink" title="输入法软件："></a>输入法软件：</h1><h2 id="搜狗输入法："><a href="#搜狗输入法：" class="headerlink" title="搜狗输入法："></a>搜狗输入法：</h2><p>搜狗输入法Linux官网-首页</p>
<h3 id="1、添加中文语言支持"><a href="#1、添加中文语言支持" class="headerlink" title="1、添加中文语言支持"></a>1、添加中文语言支持</h3><p>打开 系统设置——区域和语言——管理已安装的语言——在“语言”tab下——点击“添加或删除语言”<br><img src="https://pic1.zhimg.com/80/v2-b248e5b921fa3cde2c018dbb74a09a68_720w.jpg"><br>弹出“已安装语言”窗口，勾选中文（简体），点击应用<br><img src="https://pic2.zhimg.com/80/v2-9784e564cfb3f4d55a89b0a9b459e7b5_720w.jpg"><br>回到“语言支持”窗口，在键盘输入法系统中，选择“fcitx”<br><img src="https://pic3.zhimg.com/80/v2-6ac417d2e68d2a9ab99b17f034fd3742_720w.jpg"></p>
<p>如果在键盘输入法系统中，没有“fcitx”选项时，建议先打开终端手动安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fcitx：sudo apt-get install fcitx</span><br></pre></td></tr></table></figure>
<p>等安装成功之后再执行上述步骤</p>
<p>点击“应用到整个系统”，关闭窗口，重启电脑</p>
<h3 id="2-通过命令行安装搜狗输入法"><a href="#2-通过命令行安装搜狗输入法" class="headerlink" title="2.通过命令行安装搜狗输入法"></a>2.通过命令行安装搜狗输入法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i sogoupinyin_版本号_amd64.deb</span><br></pre></td></tr></table></figure>
<p>如果安装过程中提示缺少相关依赖，则执行如下命令解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt -f install</span><br></pre></td></tr></table></figure>
<h3 id="3-注销计算机即可正常使用搜狗输入法。"><a href="#3-注销计算机即可正常使用搜狗输入法。" class="headerlink" title="3.注销计算机即可正常使用搜狗输入法。"></a>3.注销计算机即可正常使用搜狗输入法。</h3><h1 id="文档软件："><a href="#文档软件：" class="headerlink" title="文档软件："></a>文档软件：</h1><h2 id="Wps："><a href="#Wps：" class="headerlink" title="Wps："></a>Wps：</h2><p>WPS Office因酷似微软 Office 而广受欢迎。它的界面与微软 Office 几乎一样并且号称与微软 Office 更加兼容。<br><a href="https://www.wps.cn/product/wpslinux">https://www.wps.cn/product/wpslinux</a></p>
<h2 id="LibreOffice："><a href="#LibreOffice：" class="headerlink" title="LibreOffice："></a>LibreOffice：</h2><p>它是个组件完整的办公软件，包括文档编辑器、电子表格工具、演示软件、数学工具和作图工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libreoffice libreoffice-style-breeze</span><br></pre></td></tr></table></figure>
<h1 id="音乐软件："><a href="#音乐软件：" class="headerlink" title="音乐软件："></a>音乐软件：</h1><h2 id="网易云："><a href="#网易云：" class="headerlink" title="网易云："></a>网易云：</h2><p><a href="https://music.163.com/#/download">https://music.163.com/#/download</a></p>
<h1 id="聊天软件："><a href="#聊天软件：" class="headerlink" title="聊天软件："></a>聊天软件：</h1><h2 id="QQ："><a href="#QQ：" class="headerlink" title="QQ："></a>QQ：</h2><p><a href="https://im.qq.com/linuxqq/download.html">https://im.qq.com/linuxqq/download.html</a></p>
<h1 id="其他一些常用软件安装与使用："><a href="#其他一些常用软件安装与使用：" class="headerlink" title="其他一些常用软件安装与使用："></a>其他一些常用软件安装与使用：</h1><h2 id="VNC的使用及常见问题："><a href="#VNC的使用及常见问题：" class="headerlink" title="VNC的使用及常见问题："></a>VNC的使用及常见问题：</h2><h3 id="启动VNC"><a href="#启动VNC" class="headerlink" title="启动VNC"></a>启动VNC</h3><p>设置里打开共享<br><img src="https://pic3.zhimg.com/80/v2-bdad4403c861b8070edf35e06abc3f0a_720w.jpg"><br>设置密码并打开选项<br><img src="https://pic2.zhimg.com/80/v2-fe2ab52e283125190f7d46422d01d1a9_720w.jpg"><br>如果没有屏幕共享选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install dconf-editor</span><br></pre></td></tr></table></figure>
<p>或者，如果尚未安装 vino，请同时执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vino dconf-editor</span><br></pre></td></tr></table></figure>
<p>打开dconf-editor工具，终端输入 dconf-editor打开</p>
<p>打开之后，依次展开org-&gt;gnome-&gt;desktop-&gt;remote-access<br><img src="https://pic2.zhimg.com/80/v2-863b0116f3f2f976dda4a8c19f281259_720w.jpg"><br>打开相关选项即可。</p>
<h3 id="如果无法连接VNC服务端"><a href="#如果无法连接VNC服务端" class="headerlink" title="如果无法连接VNC服务端"></a>如果无法连接VNC服务端</h3><p>报错信息如下：</p>
<p>Unable to connect to VNC Server using your chosen security setting. Either upgrade VNC Server to a more recent version from RealVNC, or select a weaker level of encryption</p>
<p>解决办法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.Vino require-encryption <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="SSR："><a href="#SSR：" class="headerlink" title="SSR："></a>SSR：</h2><p>科学上网工具，下载地址：<br><a href="https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb">https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb</a></p>
<h2 id="GDebi："><a href="#GDebi：" class="headerlink" title="GDebi："></a>GDebi：</h2><p>Gedbi 是一款小巧的软件包管理器，你可以用它来安装 DEB 文件。它比软件中心更快，而且还能处理依赖问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdebi</span><br></pre></td></tr></table></figure>

<h2 id="Visual-Studio-Code："><a href="#Visual-Studio-Code：" class="headerlink" title="Visual Studio Code："></a>Visual Studio Code：</h2><p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
<h2 id="Steam："><a href="#Steam：" class="headerlink" title="Steam："></a>Steam：</h2><p><a href="https://store.steampowered.com/about/">https://store.steampowered.com/about/</a></p>
<h2 id="误删一些安装包导致无法打开系统设置："><a href="#误删一些安装包导致无法打开系统设置：" class="headerlink" title="误删一些安装包导致无法打开系统设置："></a>误删一些安装包导致无法打开系统设置：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnome-control-center</span><br></pre></td></tr></table></figure>

<h1 id="个人的一些感想："><a href="#个人的一些感想：" class="headerlink" title="个人的一些感想："></a>个人的一些感想：</h1><p>经过几天的使用，我发现Ubuntu在配置好环境后，日常体验还是相当不错的。</p>
<p>但相对繁琐的软件安装步骤（学习成本较高）以及传统软件的缺乏（比如office全家桶）还是会让人放弃把Ubuntu或者其他Linux发行版作为日常使用的系统，即使 Linux 开发了相应的 Windows 软件替代品，使用体验还是不如Windows的。虽然 Linux 中网络是可靠的，但与 Windows 之间还是有差异的，不像 Windows 那样易于上手。并且Linux 的显卡支持也很麻烦，也缺乏 3A 游戏。尽管Steam Deck的系统是基于Linux，但可以在Linux上流畅运行的游戏还是相对比较少的。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派系统烧录教程</title>
    <url>/archives/6a0755b3.html</url>
    <content><![CDATA[<p>树莓派的系统烧录大体上可分为使用</p>
<p>官方的烧录工具Raspberry Pi Imager烧录和使用第三方烧录工具烧录。</p>
<p>官方的烧录工具胜在操作简单，方便快捷，所以这里使用Raspberry Pi Imager进行演示。</p>
<p>具体步骤如下：</p>
<p>首先准备好tf卡和读卡器</p>
<p>然后进入官网下载 <a href="https://link.zhihu.com/?target=https://www.raspberrypi.com/software/">Raspberry Pi Imager</a></p>
<p><img src="https://pic4.zhimg.com/80/v2-8a14d7c95dec632584c034d0dc88b28b_720w.jpg" alt="选择download for windows"></p>
<p>安装Raspberry Pi Imager<br><img src="https://pic1.zhimg.com/80/v2-c4e4c22348914ce68edf31226bb6f340_720w.jpg" alt="点击Install"><br><img src="https://pic2.zhimg.com/80/v2-84775579e1f5e109e7cfb486f4aab445_720w.jpg" alt="Finish"></p>
<p>打开Raspberry Pi Imager<br><img src="https://pic4.zhimg.com/80/v2-4eae49e0a08f4a124f1a8a74ebc7970b_720w.jpg" alt="点击CHOOSE OS选项"></p>
<p>这里我们可以看到有很多系统可供选择，可以自行选择适合的系统，</p>
<p>这里我们选择带有树莓派桌面的第一个系统为例<br><img src="https://pic2.zhimg.com/80/v2-112d84b8ae1fa0b9dcd92a6325576ae9_720w.jpg" alt="点击Raspberry PI OS(32-bit)"></p>
<p>选择对应的存储设备<br><img src="https://pic1.zhimg.com/80/v2-a5d82eae153723595f4c1944cf3f797c_720w.jpg" alt="点击CHOOSE STORAGE选项"><br><img src="https://pic3.zhimg.com/80/v2-f6cf4fe01e8b59da659a6e37c9db9aae_720w.jpg" alt="注意所选盘符是否为目标tf卡"></p>
<p>烧录程序<br><img src="https://pic4.zhimg.com/80/v2-16125a207574f1440b2e52738d1a7c47_720w.jpg" alt="点击WRITE"><br><img src="https://pic1.zhimg.com/80/v2-71484bd203bca4874eeb82a93026a360_720w.jpg" alt="点击yes"></p>
<p>接下来耐心等待即可<br><img src="https://pic4.zhimg.com/80/v2-7d813e812b9816d4339a448576daa9bf_720w.jpg" alt="等进度条达100％即完成树莓派系统的烧录"></p>
<p>如果出现报错，可以尝试重新烧录系统。</p>
]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（一）</title>
    <url>/archives/5dd58e55.html</url>
    <content><![CDATA[<h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><p>计算机网络是“以相互共享资源的方式互联起来的自治计算机系统的集合”。<br>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><p>计算机网络按照其覆盖的地理范围进行分类，可以很好地反映不同类型网络的技术特征。按照覆盖的地理范围划分，计算机网络可以分为以下5类。</p>
<h3 id="广域网（Wide-Area-Network，WAN）"><a href="#广域网（Wide-Area-Network，WAN）" class="headerlink" title="广域网（Wide Area Network，WAN）"></a>广域网（Wide Area Network，WAN）</h3><h3 id="城域网-Metropolitan-Area-Network，MAN"><a href="#城域网-Metropolitan-Area-Network，MAN" class="headerlink" title="城域网(Metropolitan Area Network，MAN)"></a>城域网(Metropolitan Area Network，MAN)</h3><h3 id="局域网（Local-Area-Network-，LAN）"><a href="#局域网（Local-Area-Network-，LAN）" class="headerlink" title="局域网（Local Area Network ，LAN）"></a>局域网（Local Area Network ，LAN）</h3><h3 id="个人区域网（Personal-Area-Network，PAN）"><a href="#个人区域网（Personal-Area-Network，PAN）" class="headerlink" title="个人区域网（Personal Area Network，PAN）"></a>个人区域网（Personal Area Network，PAN）</h3><h3 id="人体区域网（Body-Area-Network，BAN）"><a href="#人体区域网（Body-Area-Network，BAN）" class="headerlink" title="人体区域网（Body Area Network，BAN）"></a>人体区域网（Body Area Network，BAN）</h3><h3 id="网络体系结构和网络协议"><a href="#网络体系结构和网络协议" class="headerlink" title="网络体系结构和网络协议"></a>网络体系结构和网络协议</h3><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议类似于人类协议，除了交换报文和采取动作的实体是某些设备（可以是计算机、智能手机、平板电脑、路由器或其他具有网络能力的设备）的硬件或软件组件。在因 特网中，涉及两个或多个远程通信实体的所有活动都受协议的制约。例如，在两台物理上 连接的计算机中，硬件实现的协议控制了在两块网络接口卡间的“线上”的比特流；在端 系统中，拥塞控制协议控制了在发送方和接收方之间传输的分组发送的速率；路由器中的协议决定了分组从源到目的地的路径。<br>协议（protocol）定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接收一条报文或其他事件所采取的动作。<br>因特网（更一般地说是计算机网络）广泛地使用了协议。不同的协议用于完成不同的通信任务。<br>    层次（layer）结构事处理计算机网络问题最基本的方法。对于一些难以处理的复杂问题，通常是采用若干个容易处理的、小一些的问题，“化整为零，分而治之”的方法去解决。<br>接口是同一主机内相邻层之间交换信息的连接点。<br>对于结构复杂的网络协议体系来说，最好的组织方是层次结构模型。计算机网络引入了一个重要的概念——网络体系结构（network architecture）。</p>
<h2 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h2><p>1974年，IBM公司提出世界第一个网络体系结构——系统网络体系结构（SNA）。1974年，国际标准化组织（ISO）发布了著名的ISO&#x2F;IEC7498标准，定义了网络互联的7层框架，即开放系统互连（Open System Interconnect，OSI）参考模型。<br>开放系统互连 (OSI) 模型描述了计算机系统用于通过网络进行通信的七个层次。OSI参考模型包括以下七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。<br><img src="https://pic3.zhimg.com/80/v2-82a2e89aa4a4218d23a8aedba5b77ad2_720w.jpg" alt="OSI七层模型"></p>
<p>现代互联网不是基于 OSI，而是基于更简单的 TCP&#x2F;IP 模型。然而，OSI 7 层模型仍然被广泛使用，因为它有助于可视化和传达网络的运行方式，并有助于隔离和解决网络问题。<br>我们将“自上而下”地描述 OSI 层，从直接为最终用户服务的应用程序层，一直到物理层。<br><img src="https://pic1.zhimg.com/80/v2-112f5d6be901f464ec832561b4f98f48_720w.jpg" alt="主机、路由器和链路层交换机，每个包含了不同的层，反映了它们的功能差异"></p>
<h3 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h3><p>应用层由最终用户软件使用，例如 Web 浏览器和电子邮件客户端。它提供允许软件发送和接收信息并向用户呈现有意义的数据的协议。应用层协议的一些示例是超文本传输协议(HTTP)、文件传输协议 (FTP)、邮局协议 (POP)、简单邮件传输协议 (SMTP) 和域名系统 (DNS)。</p>
<h3 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6.表示层"></a>6.表示层</h3><p>表示层为应用层准备数据。它定义了两个设备应如何编码、加密和压缩数据，以便在另一端正确接收数据。表示层获取应用层传输的任何数据，并准备好通过会话层传输。</p>
<h3 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5.会话层"></a>5.会话层</h3><p>会话层在设备之间创建通信通道，称为会话。它负责打开会话，确保它们在传输数据时保持打开和功能，并在通信结束时关闭它们。会话层还可以在数据传输期间设置检查点——如果会话中断，设备可以从上一个检查点恢复数据传输。</p>
<h3 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h3><p>传输层获取会话层中传输的数据，并在发送端将其分解为“段”。它负责在接收端重新组装段，将其转换回会话层可以使用的数据。传输层进行流量控制，以与接收设备的连接速度相匹配的速率发送数据，以及错误控制，检查数据是否接收错误，如果没有，则重新请求。</p>
<h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h3><p>网络层有两个主要功能。一种是将分段分解为网络数据包，然后在接收端重新组装数据包。另一种是通过发现跨物理网络的最佳路径来路由数据包。网络层使用网络地址（通常是 Internet 协议地址）将数据包路由到目标节点。</p>
<h3 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h3><p>数据链路层在网络上两个物理连接的节点之间建立和终止连接。它将数据包分解成帧并将它们从源发送到目标。该层由两部分组成——逻辑链路控制 (LLC)，它识别网络协议、执行错误检查和同步帧，以及媒体访问控制 (MAC)，它使用 MAC 地址连接设备并定义传输和接收数据的权限。</p>
<h3 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h3><p>物理层负责网络节点之间的物理有线或无线连接。它定义了连接器、连接设备的电缆或无线技术，并负责传输原始数据，这只是一系列 0 和 1，同时负责比特率控制。<br>OSI模型的优点<br>OSI 模型帮助计算机网络的用户和运营商：<br>•	确定构建网络所需的硬件和软件。<br>•	了解并传达组件通过网络进行通信的过程。<br>•	通过确定导致问题的网络层并将工作重点放在该层来执行故障排除。<br>OSI 模型帮助网络设备制造商和网络软件供应商：<br>•	创建可以与任何其他供应商的产品进行通信的设备和软件，从而实现开放的互操作性<br>•	定义他们的产品应该使用的网络部分。<br>•	与用户沟通他们的产品在哪些网络层运行——例如，仅在应用层，或跨堆栈。</p>
<h2 id="OSI-与-TCP-x2F-IP-模型"><a href="#OSI-与-TCP-x2F-IP-模型" class="headerlink" title="OSI 与 TCP&#x2F;IP 模型"></a>OSI 与 TCP&#x2F;IP 模型</h2><p><img src="https://pic3.zhimg.com/80/v2-c39270e61b82808e07c29a4f143199d2_720w.jpg" alt="TCP/IP与OSI对应关系"></p>
<p>传输控制协议&#x2F;互联网协议(TCP&#x2F;IP) 比 OSI 模型更早，由美国国防部 (DoD) 创建。模型之间的一个关键区别是 TCP&#x2F;IP 更简单，将几个 OSI 层合并为一个：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1127aaa36d2eff825865f1020568d18f_720w.jpg" alt="TCP/IP与OSI对应关系"></p>
<p>OSI 第 5、6、7 层在 TCP&#x2F;IP 中合并为一个应用层<br>OSI 第 1 层、第 2 层在 TCP&#x2F;IP 中合并为一个网络访问层 - 但是 TCP&#x2F;IP 不负责排序和确认功能，将这些留给底层传输层。<br>其他重要区别：<br>TCP&#x2F;IP 是一种功能模型，旨在解决特定的通信问题，它基于特定的标准协议。OSI 是一个通用的、独立于协议的模型，旨在描述所有形式的网络通信。<br>在 TCP&#x2F;IP 中，大多数应用程序使用所有层，而在 OSI 中简单应用程序不使用所有七层。只有第 1、2 和 3 层是必需的才能启用任何数据通信。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Raidenxe/PicWarehouse/img/%E9%A3%8E%E6%99%AF008.png" alt="TCP/IP与OSI对应关系"></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（三）Socket基本函数详解，C++ Socket入门实战</title>
    <url>/archives/7a099087.html</url>
    <content><![CDATA[<p>在上文中，简单介绍了一下什么是socket以及简单举例Socket如何实现客户端和服务端</p>
<p>本文将会为详细地讲述Socket的一些基本函数以及如何简单使用socket搭建一个聊天室。</p>
<h2 id="Socket数据结构"><a href="#Socket数据结构" class="headerlink" title="Socket数据结构"></a>Socket数据结构</h2><p><img src="https://pic4.zhimg.com/80/v2-0b01629d0a64c309ca2fb28d027df23b_720w.jpg" alt="Socket数据结构"><br><img src="https://pic1.zhimg.com/80/v2-f3ee7745b97d088ee4a918f23761581c_720w.jpg" alt="Socket数据结构"></p>
<h2 id="Linux系统下的头文件"><a href="#Linux系统下的头文件" class="headerlink" title="Linux系统下的头文件"></a>Linux系统下的头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Windows系统下的头文件"><a href="#Windows系统下的头文件" class="headerlink" title="Windows系统下的头文件"></a>Windows系统下的头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="服务端与客户端通信过程"><a href="#服务端与客户端通信过程" class="headerlink" title="服务端与客户端通信过程"></a>服务端与客户端通信过程</h2><p><img src="https://pic3.zhimg.com/80/v2-d770bce3a03c14eb48e3aa2d24ad1dc6_720w.jpg" alt="通信过程"></p>
<h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><h3 id="套接字类型的创建"><a href="#套接字类型的创建" class="headerlink" title="套接字类型的创建"></a>套接字类型的创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> __domain, <span class="type">int</span> __type, <span class="type">int</span> __protocol)</span></span></span><br></pre></td></tr></table></figure>
<p>参数介绍</p>
<p>第一个参数domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL。</p>
<p>地址族及含义</p>
<p>AF_INET</p>
<p>IPv4网络协议中采用的地址族</p>
<p>AF_INET6</p>
<p>IPv6网络协议中采用的地址族</p>
<p>AF_LOCAL</p>
<p>本地通信中采用的UNIX协议的地址族（用的少）</p>
<p>第二个参数type：指定socket类型。常用的有SOCKET_RAW，SOCK_STREAM和SOCK_DGRAM。</p>
<p>套接字类型及含义</p>
<p>SOCKET_RAW</p>
<p>原始套接字(SOCKET_RAW)允许对较低层次的协议直接访问，比如IP、ICMP协议。</p>
<p>SOCK_STREAM是数据流，一般为TCP&#x2F;IP协议的编程。</p>
<p>SOCK_DGRAM是数据报，一般为UDP协议的网络编程；</p>
<p>第三个参数protocol：指定协议。最终采用的协议。常见的协议有IPPROTO_TCP、IPPTOTO_UDP。</p>
<p>如果第二个参数选择了SOCK_STREAM，那么采用的协议就只能是IPPROTO_TCP；</p>
<p>如果第二个参数选择的是SOCK_DGRAM，则采用的协议就只能是IPPTOTO_UDP。</p>
<p>当protocol为0时，会自动选择type类型对应的默认协议。</p>
<h3 id="向套接字分配网络类型"><a href="#向套接字分配网络类型" class="headerlink" title="向套接字分配网络类型"></a>向套接字分配网络类型</h3><p>bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<p>int bind(int __fd, const sockaddr *__addr, socklen_t __len)<br>第一个参数socket文件描述符__fd：即套接字创建时返回的对象，</p>
<p>第二个参数addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。包含通信所需要的相关信息，其结构体具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span></span><br><span class="line">  &#123;</span><br><span class="line"> <span class="type">sa_family_t</span> sin_family; <span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line"> <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">/* Address data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>在具体传参的时候，会用该结构体的变体sockaddr_in形式去初始化相关字段，该结构体具体形式如下，结构体sockaddr中的sa_data就保存着地址信息需要的IP地址和端口号，对应着结构体sockaddr_in的sin_port和sin_addr字段。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line"> <span class="type">sa_family_t</span> sin_family;     <span class="comment">//前面介绍的地址族</span></span><br><span class="line"> <span class="type">uint16_t</span> sin_port;          <span class="comment">//16位的TCP/UDP端口号</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;    <span class="comment">//32位的IP地址</span></span><br><span class="line"> <span class="type">char</span> sin_zero[<span class="number">8</span>];           <span class="comment">//不使用</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="进入等待连接请求状态"><a href="#进入等待连接请求状态" class="headerlink" title="进入等待连接请求状态"></a>进入等待连接请求状态</h3><p>给套接字分配了所需的信息后，服务端就可以调用listen()函数对来自客户端的连接请求进行监听（客户端此时要调用connect()函数进行连接）</p>
<p>Listen函数的第一个参数即为要监听的socket套接字，第二个参数为相应socket可以排队的最大连接个数。</p>
<p>Connect函数的第一个参数即为客户端的socket套接字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。</p>
<h3 id="处理服务端的连接请求"><a href="#处理服务端的连接请求" class="headerlink" title="处理服务端的连接请求"></a>处理服务端的连接请求</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> __fd, sockaddr *__restrict__ __addr, <span class="type">socklen_t</span> *__restrict__ __addr_len)</span></span></span><br></pre></td></tr></table></figure>
<p>函数成功执行时返回socket文件描述符，失败时返回-1。</p>
<p>accept函数的第一个参数为服务器的socket描述字，</p>
<p>第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，</p>
<p>第三个参数为协议地址的长度。</p>
<p>accept函数返回的是已连接的socket套接字。</p>
<h4 id="在TCP-x2F-IP协议中-TCP协议提供可靠的连接服务-采用三次握手建立一个连接。"><a href="#在TCP-x2F-IP协议中-TCP协议提供可靠的连接服务-采用三次握手建立一个连接。" class="headerlink" title="在TCP&#x2F;IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接。"></a>在TCP&#x2F;IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接。</h4><p><img src="https://pic2.zhimg.com/80/v2-9dcd196f5ff3307d2e8fe6f08b54c641_720w.jpg" alt="三次握手"></p>
<p>第一次握手：建立连接时,客户端发送syn包(syn&#x3D;j)到服务器,并进入SYN_SEND状态,等待服务器确认；</p>
<p>SYN：同步序列编号(Synchronize Sequence Numbers)</p>
<p>第二次握手：服务器收到syn包,必须确认客户的SYN（ack&#x3D;j+1）,同时自己也发送一个SYN包（syn&#x3D;k）,即SYN+ACK包,此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack&#x3D;k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手。</p>
<p>完成三次握手,客户端与服务器开始传送数据。</p>
<h4 id="四次挥手结束连接"><a href="#四次挥手结束连接" class="headerlink" title="四次挥手结束连接"></a>四次挥手结束连接</h4><p><img src="https://pic3.zhimg.com/80/v2-1a8261c7ffa27588f3d06c741311cd86_720w.jpg" alt="四次挥手"></p>
<p>由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>简单来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。</p>
<h3 id="write-x2F-send发送信息"><a href="#write-x2F-send发送信息" class="headerlink" title="write&#x2F;send发送信息"></a>write&#x2F;send发送信息</h3><p>Linux下的发送函数为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">const</span> <span class="type">void</span> *__buf, <span class="type">size_t</span> __n)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>而在Windows下的发送函数为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flag)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>第四个参数是传输数据时可指定的信息，一般设置为0。</p>
<h3 id="read-x2F-recv接受信息"><a href="#read-x2F-recv接受信息" class="headerlink" title="read&#x2F;recv接受信息"></a>read&#x2F;recv接受信息</h3><p>linux下的接收函数为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> __fd, <span class="type">void</span> *__buf, <span class="type">size_t</span> __n, <span class="type">int</span> __flags)</span></span></span><br></pre></td></tr></table></figure>
<p>而在windows下的接收函数为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flag)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数指定接收端套接字描述符；</p>
<p>第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</p>
<p>第三个参数指明buf的长度；</p>
<p>第四个参数一般置0</p>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> __fd)</span></span></span><br></pre></td></tr></table></figure>
<p>退出连接，此时要注意的是：调用close()函数即表示向对方发送了EOF结束标志信息。</p>
<h3 id="C-x2F-C-代码实战"><a href="#C-x2F-C-代码实战" class="headerlink" title="C&#x2F;C++代码实战"></a>C&#x2F;C++代码实战</h3><p>以下代码仅供参考，且在Linux环境下运行，需要先运行服务端再运行客户端，仅能实现客户端给服务端发送信息的简单功能。</p>
<h4 id="client-cpp"><a href="#client-cpp" class="headerlink" title="client.cpp"></a>client.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYPORT 7000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> sockCli = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">///定义sockaddr_in</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"> <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"> servaddr.sin_family = AF_INET;</span><br><span class="line"> servaddr.sin_port = <span class="built_in">htons</span>(MYPORT);                 <span class="comment">//服务器端口</span></span><br><span class="line"> servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">//服务器ip，inet_addr用于IPv4的IP转换（十进制转换为二进制）</span></span><br><span class="line">                                                       <span class="comment">// 127.0.0.1是本地预留地址</span></span><br><span class="line">                                                       <span class="comment">//连接服务器，成功返回0，错误返回-1</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">connect</span>(sockCli, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="type">char</span> sendbuf[BUFFER_SIZE];</span><br><span class="line"> <span class="type">char</span> recvbuf[BUFFER_SIZE];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span> (<span class="built_in">fgets</span>(sendbuf, <span class="built_in">sizeof</span>(sendbuf), stdin) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;                                               <span class="comment">/*每次读取一行，读取的数据保存在buf指向的字符数组中，成功，则返回第一个参数buf；*/</span></span><br><span class="line"> <span class="built_in">send</span>(sockCli, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>); <span class="comment">///发送</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(sendbuf, <span class="string">&quot;exit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// recv(sockCli, recvbuf, sizeof(recvbuf), 0); ///接收</span></span><br><span class="line">        <span class="comment">// fputs(recvbuf, stdout);</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(sendbuf)); <span class="comment">//接受或者发送完毕后把数组中的数据全部清空（置0）</span></span><br><span class="line"> <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="built_in">close</span>(sockCli);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Server-cpp"><a href="#Server-cpp" class="headerlink" title="Server.cpp"></a>Server.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 7000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE 20 <span class="comment">//连接请求队列</span></span></span><br><span class="line"><span class="type">int</span> conn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> sockSer = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//若成功则返回一个sockfd（套接字描述符）</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_sockaddr;            <span class="comment">//一般是储存地址和端口的。用于信息的显示及存储使用</span></span><br><span class="line">                                                   <span class="comment">/*设置 sockaddr_in 结构体中相关参数*/</span></span><br><span class="line"> server_sockaddr.sin_family = AF_INET;</span><br><span class="line"> server_sockaddr.sin_port = <span class="built_in">htons</span>(PORT); <span class="comment">//将一个无符号短整型数值转换为网络字节序，即大端模式(big-endian) </span></span><br><span class="line">                                            <span class="comment">// printf(&quot;%d\n&quot;,INADDR_ANY);</span></span><br><span class="line">    <span class="comment">// INADDR_ANY就是指定地址为0.0.0.0的地址，这个地址事实上表示不确定地址，或“所有地址”、“任意地址”。</span></span><br><span class="line">    <span class="comment">//一般来说，在各个系统中均定义成为0值。</span></span><br><span class="line"> server_sockaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//将主机的无符号长整形数转换成网络字节顺序。</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">bind</span>(sockSer, (<span class="keyword">struct</span> sockaddr *)&amp;server_sockaddr, <span class="built_in">sizeof</span>(server_sockaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">listen</span>(sockSer, QUEUE) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line"> <span class="type">socklen_t</span> length = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="comment">///成功返回非负描述字，出错返回-1</span></span><br><span class="line"> conn = <span class="built_in">accept</span>(sockSer, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;length);</span><br><span class="line">    <span class="comment">//如果accpet成功，那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接。</span></span><br><span class="line">    <span class="comment">// accpet之后就会用新的套接字conn</span></span><br><span class="line"> <span class="keyword">if</span> (conn &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"> <span class="type">int</span> len = <span class="built_in">recv</span>(conn, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>); <span class="comment">//从TCP连接的另一端接收数据。</span></span><br><span class="line">        <span class="comment">/*该函数的第一个参数指定接收端套接字描述符；</span></span><br><span class="line"><span class="comment"> 第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</span></span><br><span class="line"><span class="comment"> 第三个参数指明buf的长度；</span></span><br><span class="line"><span class="comment"> 第四个参数一般置0*/</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;exit\n&quot;</span>) == <span class="number">0</span>) <span class="comment">//如果没有收到TCP另一端发来的数据则跳出循环不输出</span></span><br><span class="line">        &#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer); <span class="comment">//如果有收到数据则输出数据</span></span><br><span class="line">        <span class="comment">//必须要有返回数据， 这样才算一个完整的请求</span></span><br><span class="line"> <span class="built_in">send</span>(conn, buffer, len, <span class="number">0</span>); <span class="comment">//向TCP连接的另一端发送数据。</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="built_in">close</span>(conn); <span class="comment">//因为accpet函数连接成功后还会生成一个新的套接字描述符，结束后也需要关闭</span></span><br><span class="line"> <span class="built_in">close</span>(sockSer);   <span class="comment">//关闭socket套接字描述符</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
        <tag>Socket</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（二）什么是Socket？它跟TCP/IP的关系是什么？</title>
    <url>/archives/8cdebc07.html</url>
    <content><![CDATA[<h2 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h2><p>Socket允许在相同或不同机器上的两个不同进程之间进行通信。更准确地说，这是一种使用标准 Unix 文件描述符与其他计算机通信的方式。</p>
<p>在 Unix 中，每个 I&#x2F;O 操作都是通过写入或读取文件描述符来完成的。文件描述符只是与打开的文件相关联的整数，它可以是网络连接、文本文件、终端或其他东西。</p>
<p>对于程序员来说，套接字的外观和行为很像低级文件描述符。这是因为诸如 read() 和 write() 之类的命令对套接字的工作方式与它们对文件和管道的工作方式相同。</p>
<p>套接字最初是在 2.1BSD 中引入的，随后在 4.2BSD 中被改进为当前的形式。现在，大多数最新的 UNIX 系统版本都提供了套接字功能。<br><img src="https://pic1.zhimg.com/80/v2-33d5adb9c5bdefa9977a7f64970834a0_720w.jpg" alt="Socket与各种网络协议的关系"><br>如图所示，Socket是为了给应用程序一个更加统一、简洁的API接口而将底层各种协议栈封装起来形成形成的一层接口函数。</p>
<p>简单举例Socket如何实现客户端和服务端<br><img src="https://pic3.zhimg.com/80/v2-50a90c813007b71ef251e00f5cf7692e_720w.jpg" alt="客户端和服务端信息交互"><br>构建客户端和服务器的方式有所不同，但都涉及到Socket的基本构造。这两个进程都建立了自己的套接字。</p>
<h2 id="如何构建客户端"><a href="#如何构建客户端" class="headerlink" title="如何构建客户端"></a>如何构建客户端</h2><p>在客户端建立Socket的步骤如下 ：</p>
<p>1.使用socket()系统调用创建一个套接字。</p>
<p>2.使用connect()系统调用将套接字连接到服务器的地址。</p>
<p>3.发送和接收数据。有很多方式可以实现这一点，最简单的方法就是使用read()和write()系统调用。</p>
<h2 id="如何构建服务端"><a href="#如何构建服务端" class="headerlink" title="如何构建服务端"></a>如何构建服务端</h2><p>在服务器端建立套接字的步骤如下 ：</p>
<p>1.使用socket()系统调用创建一个套接字。</p>
<p>2.使用bind()系统调用将套接字绑定到一个地址。对于 Internet 上的服务器套接字，地址由主机上的端口号组成。</p>
<p>3.通过listen()系统调用监听连接。</p>
<p>4.通过accept()系统调用接受连接。此调用通常会阻止连接，直到客户端与服务器连接。</p>
<p>5.使用read()和write()系统调用发送和接收数据。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（四）Linux C++ Socket实现“伪”半双工聊天室程序</title>
    <url>/archives/cf06f66d.html</url>
    <content><![CDATA[<p>在上文中，讲述了Socket的一些基本函数以及如何简单使用Socket搭建一个单工聊天的聊天室程序。</p>
<p>本文的目标便是对这个简单的程序加以改进，使其能实现服务端和客户端之间的相互通信。如果想更深入理解，推荐大家阅读《UNIX网络编程卷1套接字联网API》这本书。</p>
<h2 id="首先需要补充一些我之前没有提到过的知识点。"><a href="#首先需要补充一些我之前没有提到过的知识点。" class="headerlink" title="首先需要补充一些我之前没有提到过的知识点。"></a>首先需要补充一些我之前没有提到过的知识点。</h2><h3 id="Socket处于网络协议的哪个层次？"><a href="#Socket处于网络协议的哪个层次？" class="headerlink" title="Socket处于网络协议的哪个层次？"></a>Socket处于网络协议的哪个层次？</h3><p><img src="https://pic4.zhimg.com/80/v2-728b741914df045b9cdfb918a30d1843_720w.jpg" alt="socket网络层次"><br>套接字编程接口是从顶上三层（网际协议的应用层）进入传输层的接口。</p>
<h3 id="为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口"><a href="#为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口" class="headerlink" title="为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口?"></a>为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口?</h3><p>这样设计有两个理由，如图1-14右侧所注。理由之一是顶上三层处理具体网络应用（如FTP、Telnet或HTTPO的所有细节，却对通信细节了解很少;底下四层对具体网络应用了解不多，却处理所有的通信细节:发送数据，等待确认，给无序到达的数据排序，计算并验证校验和，等等。理由之二是顶上三层通常构成所谓的用户进程user process口,底下四层却通常作为操作系统内核的一部分提供。Unix与其他现代操作系统都提供分隔用户进程与内核的机制。由此可见，第4层和第5层之间的接口是构建API的自然位置。</p>
<h2 id="TCP实现框架"><a href="#TCP实现框架" class="headerlink" title="TCP实现框架"></a>TCP实现框架</h2><p><img src="https://pic1.zhimg.com/80/v2-dfaeec3f74165f5a74c278a513d54ab8_720w.jpg" alt="TCP实现框架"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>目前该代码尚不完善，仅供参考，只能实现一发送一接收的“伪”半双工通信。真正的半双工(Half Duplex)数据传输，数据可以随时发送，只是不能同时传输。</p>
<h2 id="Sever-cpp"><a href="#Sever-cpp" class="headerlink" title="Sever.cpp"></a>Sever.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 7000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024 <span class="comment">//缓冲区大小宏定义</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"> <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]); <span class="comment">//将输入的端口号由字符串转换为整数类型</span></span><br><span class="line">    <span class="comment">//结构体定义与初始化</span></span><br><span class="line"> <span class="type">int</span> sockSer = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//若成功则返回一个sockfd（套接字描述符）</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_sockaddr;            <span class="comment">//一般是储存地址和端口的。用于信息的显示及存储使用</span></span><br><span class="line">                                                   <span class="comment">//设置 sockaddr_in 结构体中相关参数</span></span><br><span class="line"> server_sockaddr.sin_family = AF_INET;</span><br><span class="line"> server_sockaddr.sin_port = <span class="built_in">htons</span>(PORT); <span class="comment">//将一个无符号短整型数值转换为网络字节序，即大端模式(big-endian) </span></span><br><span class="line">                                            <span class="comment">// printf(&quot;%d\n&quot;,INADDR_ANY);</span></span><br><span class="line">    <span class="comment">// INADDR_ANY就是指定地址为0.0.0.0的地址，这个地址事实上表示不确定地址，或“所有地址”、“任意地址”。</span></span><br><span class="line">    <span class="comment">//一般来说，在各个系统中均定义成为0值。</span></span><br><span class="line">    <span class="comment">// server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); //将主机的无符号长整形数转换成网络字节顺序。</span></span><br><span class="line"> <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;server_sockaddr.sin_addr); <span class="comment">//将小端字节序转换为网络字节序</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">assert</span>(sockSer &gt;= <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> ret = <span class="built_in">bind</span>(sockSer, (<span class="keyword">struct</span> sockaddr *)&amp;server_sockaddr, <span class="built_in">sizeof</span>(server_sockaddr)); <span class="comment">//绑定IP地址、端口号等信息</span></span><br><span class="line"> <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"> ret = <span class="built_in">listen</span>(sockSer, <span class="number">5</span>); <span class="comment">//监听有无连接请求</span></span><br><span class="line"> <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line"> <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="comment">///成功返回非负描述字，出错返回-1</span></span><br><span class="line"> <span class="type">int</span> connfd = <span class="built_in">accept</span>(sockSer, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_addrlength); <span class="comment">//从监听队列中取出第一个已完成的连接</span></span><br><span class="line"> <span class="type">char</span> buffer_recv[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">char</span> buffer_send[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;errno is : %d\n&quot;</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"> <span class="built_in">memset</span>(buffer_recv, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line"> <span class="built_in">memset</span>(buffer_send, <span class="number">0</span>, BUFFER_SIZE); <span class="comment">//每次需要为缓冲区清空</span></span><br><span class="line"> </span><br><span class="line"> ret = <span class="built_in">recv</span>(connfd, buffer_recv, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer_recv, <span class="string">&quot;quit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Communications is over!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">// recv为quit表示客户端请求断开连接，退出循环</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;client:%s&quot;</span>, buffer_recv);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;server:&quot;</span>);</span><br><span class="line"> <span class="built_in">fgets</span>(buffer_send, BUFFER_SIZE, stdin);</span><br><span class="line"> <span class="built_in">send</span>(connfd, buffer_send, <span class="built_in">strlen</span>(buffer_send), <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer_send, <span class="string">&quot;quit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Communications is over!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">// send为quit表示服务器请求断开连接，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">close</span>(connfd);</span><br><span class="line"> <span class="built_in">close</span>(sockSer); <span class="comment">//关闭socket套接字描述符</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client-cpp"><a href="#Client-cpp" class="headerlink" title="Client.cpp"></a>Client.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"> <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> sockCli = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"> <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"> servaddr.sin_family = AF_INET;</span><br><span class="line"> servaddr.sin_port = <span class="built_in">htons</span>(port); <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="comment">// servaddr.sin_addr.s_addr = htons(port);</span></span><br><span class="line"> <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;servaddr.sin_addr); <span class="comment">//将点分文本的IP地址转换为二进制网络字节序的IP地址</span></span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> sockfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">assert</span>(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> connfd = <span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"> </span><br><span class="line"> <span class="type">char</span> sendbuf[BUFFER_SIZE];</span><br><span class="line"> <span class="type">char</span> recvbuf[BUFFER_SIZE];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"> <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line"> <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;client:&quot;</span>);</span><br><span class="line"> <span class="built_in">fgets</span>(sendbuf, BUFFER_SIZE, stdin);</span><br><span class="line"> <span class="built_in">send</span>(sockfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(sendbuf, <span class="string">&quot;quit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Communications is over!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">//send为quit表示客户端请求断开连接，退出循环</span></span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, recvbuf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(recvbuf, <span class="string">&quot;quit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Communications is over!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">//recv为quit表示服务器请求断开连接，退出循环</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;server:%s&quot;</span>, recvbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="built_in">close</span>(connfd);</span><br><span class="line"> <span class="built_in">close</span>(sockCli);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
        <tag>Socket</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点（五） I/O 多路复用：函数select、poll和epoll</title>
    <url>/archives/884564f6.html</url>
    <content><![CDATA[<h1 id="什么是IO多路复用？"><a href="#什么是IO多路复用？" class="headerlink" title="什么是IO多路复用？"></a>什么是IO多路复用？</h1><p>IO即为网络I&#x2F;O，多路即为多个TCP连接，复用即为共用一个线程或者进程，模型最大的优势是系统开销小，不必创建也不必维护过多的线程或进程。</p>
<p>IO复用(IOmultiplexing)使得内核一旦发现进程指定的一个或多个IO条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出)，它就通知进程。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>I&#x2F;O 多路复用通常用于以下场景的网络应用：</p>
<p>当客户端处理多个描述符时（通常是交互式输入和网络套接字）</p>
<p>当客户端同时处理多个套接字时（这是可能的，但很少见）</p>
<p>如果 TCP 服务器同时处理侦听套接字及其连接的套接字</p>
<p>如果服务器同时处理 TCP 和 UDP</p>
<p>如果服务器处理多个服务，可能还有多个协议</p>
<p>I&#x2F;O 多路复用不限于网络编程。许多重要的应用程序发现需要这些技术。</p>
<h1 id="输入-x2F-输出模型"><a href="#输入-x2F-输出模型" class="headerlink" title="输入&#x2F;输出模型"></a>输入&#x2F;输出模型</h1><p>我们首先检查 Unix 下可用的五种 I&#x2F;O 模型的基本区别：</p>
<p><strong>[1]blockingIO - 阻塞I&#x2F;O</strong></p>
<p><strong>[2]nonblockingIO - 非阻塞I&#x2F;O</strong></p>
<p><strong>[3]IOmultiplexing – I&#x2F;O多路复用（select和poll）</strong></p>
<p><strong>[4]signaldrivenIO - 信号驱动I&#x2F;O</strong></p>
<p><strong>[5]asynchronousIO - 异步I&#x2F;O（POSIX aio函数）</strong></p>
<h2 id="输入操作通常有两个不同的阶段："><a href="#输入操作通常有两个不同的阶段：" class="headerlink" title="输入操作通常有两个不同的阶段："></a>输入操作通常有两个不同的阶段：</h2><p>1等待数据准备好。这涉及等待数据到达网络。当数据包到达时，它被复制到内核中的缓冲区中。</p>
<p>2将数据从内核复制到进程。这意味着将（准备好的）数据从内核缓冲区复制到我们的应用程序缓冲区</p>
<h1 id="阻塞-I-x2F-O-模型"><a href="#阻塞-I-x2F-O-模型" class="headerlink" title="阻塞 I&#x2F;O 模型"></a>阻塞 I&#x2F;O 模型</h1><p>最流行的 I&#x2F;O 模型是阻塞 I&#x2F;O 模型（我们在前面部分的所有示例中都使用了该模型）。默认情况下，所有套接字都是阻塞的。场景如下图所示：<br><img src="https://pic4.zhimg.com/80/v2-728b741914df045b9cdfb918a30d1843_720w.jpg" alt="阻塞I/O模型"></p>
<p>使用UDP而不是TCP作为例子的原因在于就UDP而言，数据准备好读取的概念比较简单:要么整个数据报已经收到，要么还没有。然而对于TCP来说，诸如套接字低水位标记( low-water mark）等额外变量开始起作用，导致这个概念变得复杂。</p>
<p>在这个例子中,我们把recvfrom函数视为系统调用,因为我们正在区分应用进程和内核。不论它如何实现(在源自Berkeley的内核上是作为系统调用，在System V内核上是作为调用系统调用getmsg的函数)，一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间之后再切换回来。</p>
<h1 id="非阻塞-I-x2F-O-模型"><a href="#非阻塞-I-x2F-O-模型" class="headerlink" title="非阻塞 I&#x2F;O 模型"></a>非阻塞 I&#x2F;O 模型</h1><p>当套接字设置为非阻塞时，我们是在告诉内核“当我请求的 I&#x2F;O 操作在不让进程进入睡眠状态的情况下无法完成时，不要让进程进入睡眠状态，而是返回一个错误”。</p>
<p><img src="https://pic3.zhimg.com/80/v2-fb59340a9864676a60e9bdcfbd523dca_720w.jpg" alt="非阻塞I/O模型"><br>对于前三个recvfrom，没有要返回的数据，内核立即返回一个错误EWOULDBLOCK。<br>我们第四次调用recvfrom，数据报准备好了，它被复制到我们的应用程序缓冲区，并recvfrom成功返回。然后我们处理数据。<br>当应用程序处于循环调用recvfrom这样的非阻塞描述符时，它被称为轮询。应用程序不断地轮询内核以查看某些操作是否已准备好。这通常会浪费 CPU 时间，但偶尔会遇到这种模型，通常在专用于一个功能的系统上。</p>
<h1 id="I-x2F-O-复用模型"><a href="#I-x2F-O-复用模型" class="headerlink" title="I&#x2F;O 复用模型"></a>I&#x2F;O 复用模型</h1><p>有了IO复用(IO multiplexing)，我们就可以调用select或poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。</p>
<p><img src="https://pic2.zhimg.com/80/v2-824e9b31fc2e72d02956b72dc622c751_720w.jpg" alt="IO复用"></p>
<p>我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据报复制到应用进程缓冲区。</p>
<p>与阻塞型IO比较，IO复用并不显得有什么优势，事实上由于使用select需要两个而不是单个系统调用，IO复用还稍有劣势。，使用select的优势在于我们可以等待多个描述符就绪。</p>
<h1 id="异步-I-x2F-O-模型"><a href="#异步-I-x2F-O-模型" class="headerlink" title="异步 I&#x2F;O 模型"></a>异步 I&#x2F;O 模型</h1><p>异步 I&#x2F;O由 POSIX 规范定义，各种标准中出现的实时功能的各种差异共同形成了当前的 POSIX 规范。</p>
<p>我们也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们。我们称这种模型为信号驱动式IO ( signal-driven I&#x2F;O)。</p>
<p><img src="https://pic1.zhimg.com/80/v2-dc3e4fbed4a71e550f0b422e268b70a8_720w.jpg" alt="异步IO"></p>
<p>我们首先开启套接字的信号驱动式I&#x2F;O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个sIGIo信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。</p>
<p>无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知:既可以是数据已准备好被处理，也可以是数据报已准备好被读取。</p>
<h1 id="各种I-x2F-O模型的比较"><a href="#各种I-x2F-O模型的比较" class="headerlink" title="各种I&#x2F;O模型的比较"></a>各种I&#x2F;O模型的比较</h1><p>对比上述5种不同的IO模型。可以看出，前4种模型的主要区别在于第一阶段，因为它们的第二阶段是一样的:在数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom调用。相反，异步I&#x2F;O模型在这两个阶段都要处理，从而不同于其他4种模型。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e393476a5386a92c319e5e163166fc53_720w.jpg" alt="IO模型比较"></p>
<h1 id="同步IO和异步IO对比"><a href="#同步IO和异步IO对比" class="headerlink" title="同步IO和异步IO对比"></a>同步IO和异步IO对比</h1><p>POSIX把这两个术语定义如下:</p>
<p>同步IO操作(synchronous IO opetation）导致请求进程阻塞，直到IO操作完成;</p>
<p>异步IO操作（ asynchronous I&#x2F;O opetation）不导致请求进程阻塞。<br><img src="https://pic4.zhimg.com/80/v2-2c642bd2b7ef29542c3145e221cd2f97_720w.jpg"></p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>select 是操作系统提供的系统调用函数，select()用来等待文件描述词（普通文件、终端、伪终端、管道、FIFO、套接字及其他类型的字符型）状态的改变。是一个轮循函数，循环询问文件节点，可设置超时时间，超时时间到了就跳过代码继续往下执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">​<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数据结构 (bitmap)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">int</span> max_fd, </span></span></span><br><span class="line"><span class="params"><span class="function"> fd_set *readset, </span></span></span><br><span class="line"><span class="params"><span class="function"> fd_set *writeset, </span></span></span><br><span class="line"><span class="params"><span class="function"> fd_set *exceptset, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">struct</span> timeval *timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">// 返回值就绪描述符的数目</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span> <span class="comment">// 清空集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span> <span class="comment">// 将给定的描述符加入集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span> <span class="comment">// 判断指定描述符是否在集合中 </span></span></span><br><span class="line"><span class="function"><span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span> <span class="comment">// 将给定的描述符从文件中删除 </span></span></span><br></pre></td></tr></table></figure>
<p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p>
<p>一般来说这个数目和系统内存关系很大，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看。32位机默认是1024个。64位机默认是2048。</p>
<p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p>
<p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。</p>
<p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p>
<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>相关函数定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">ppoll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> <span class="keyword">struct</span> timespec *tmo_p, <span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line"> <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line"> <span class="type">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line"> <span class="type">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>和select用三组文件描述符不同的是，poll只有一个pollfd数组，数组中的每个元素都表示一个需要监听IO操作事件的文件描述符。events参数是我们需要关心的事件，revents是所有内核监测到的事件。</p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>它没有最大连接数的限制</strong>，原因是它是基于链表来存储的，但是同样有一个缺点：</p>
<p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</p>
<p>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>相关函数定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> maxevents, <span class="type">int</span> timeout,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。<br>LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作<br>ET模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，或者遇到EAGAIN错误。</p>
<h2 id="epoll的优点："><a href="#epoll的优点：" class="headerlink" title="epoll的优点："></a>epoll的优点：</h2><p><strong>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</strong><br><strong>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</strong><br><strong>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</strong></p>
<p><strong>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</strong></p>
<h2 id="epoll缺点："><a href="#epoll缺点：" class="headerlink" title="epoll缺点："></a>epoll缺点：</h2><p><strong>epoll只能工作在linux下。</strong></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
