<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GitHub 443 Timed out的解决方法</title>
    <url>/archives/4dcde7a2.html</url>
    <content><![CDATA[<h1 id="GitHub-443-Timed-out解决办法"><a href="#GitHub-443-Timed-out解决办法" class="headerlink" title="GitHub 443 Timed out解决办法"></a>GitHub 443 Timed out解决办法</h1><h2 id="Failed-to-connect-to-github-com-port-443-after-21090-ms-Timed-out"><a href="#Failed-to-connect-to-github-com-port-443-after-21090-ms-Timed-out" class="headerlink" title="Failed to connect to github.com port 443 after 21090 ms: Timed out"></a>Failed to connect to github.com port 443 after 21090 ms: Timed out</h2><p>最近尝试过很多方法都无法解决GitHub的上传问题，包括取消全局代理也无效。</p>
<p>取消全局代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<p>无奈之下只能选择修改hosts文件。</p>
<p>登录以下三个网站获取对应的ip地址，写入hosts文件即可。</p>
<p><a href="https://ipaddress.com/website/github.com">GitHub IP地址</a></p>
<p><img src="https://pic3.zhimg.com/80/v2-7a0b82ecaa96fdc3efda9e4295ab1eee_720w.jpg" alt="GitHub IP地址"></p>
<p><a href="https://ipaddress.com/website/github.global.ssl.fastly.net#ipinfo">github.global.ssl.Fastly.net IP地址</a></p>
<p><img src="https://pic2.zhimg.com/80/v2-aed12d6e1e2bedebba9e1444bbdc83dd_720w.jpg" alt="github.global.ssl.Fastly.net IP地址"></p>
<p><a href="https://ipaddress.com/website/assets-cdn.github.com">assets-cdn.Github.com IP地址</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-05f981b555f81338eb2bb15b5ebb5338_720w.jpg" alt="assets-cdn.Github.com IP地址"></p>
<p>如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">140.82.112.4 http://GitHub.com</span><br><span class="line"></span><br><span class="line">199.232.69.194 http://github.global.ssl.Fastly.net</span><br><span class="line"></span><br><span class="line">185.199.108.153 http://assets-cdn.Github.com</span><br><span class="line"></span><br><span class="line">185.199.109.153 http://assets-cdn.Github.com</span><br><span class="line"></span><br><span class="line">185.199.110.153 http://assets-cdn.Github.com</span><br><span class="line"></span><br><span class="line">185.199.111.153 http://assets-cdn.Github.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实测有效</p>
<p><img src="https://pic3.zhimg.com/80/v2-8ed6c75a78b8c4418f8b802d5ae38a26_720w.jpg"></p>
]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文本三剑客（1）grep命令的使用</title>
    <url>/archives/1894211f.html</url>
    <content><![CDATA[<h1 id="三剑客特点及应用场景"><a href="#三剑客特点及应用场景" class="headerlink" title="三剑客特点及应用场景"></a>三剑客特点及应用场景</h1><p>awk、grep、sed是Linux操作文本的三大利器，合称文本三剑客，也是必须掌握的Linux命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。</p>
<p>grep更适合单纯的查找或匹配文本；</p>
<p>sed更适合编辑匹配到的文本；</p>
<p>awk更适合格式化文本，对文本进行较复杂格式处理。<br><img src="https://pic3.zhimg.com/80/v2-bd401d9a5fbaab317b0a66399ef52306_720w.jpg"></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式是一种符号表示法，被用来识别文本模式。</p>
<p>在某种程度上，它们与匹配文件和路径名的 shell 通配符比较相似，但其规模更庞大。许多命令行工具和大多数的编程语言 都支持正则表达式，以此来帮助解决文本操作问题。</p>
<p>正则表达式元字符由以下字符组成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^ $ . [ ] &#123; &#125; - ? * + ( ) | \</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/v2-dc157303632d607f7bfb58624abeae52_r.jpg"><br><img src="https://pic1.zhimg.com/v2-93f8991f3c04f7db08c2575a8aeede9c_r.jpg"></p>
<h1 id="grep引言"><a href="#grep引言" class="headerlink" title="grep引言"></a>grep引言</h1><p><strong>grep</strong>是一个最初用于Unix操作系统的命令行工具。在给出文件列表或标准输入后，grep会对匹配一个或多个正则表达式的文本进行搜索，并只输出匹配（或者不匹配）的行或文本。</p>
<p>grep这个应用程序最早由肯·汤普逊写成。grep原先是ed下的一个应用程序，名称来自于g&#x2F;re&#x2F;p（globally search a regular expression and print，以正则表达式进行全局查找以及打印）。在ed下，输入g&#x2F;re&#x2F;p这个命令后，会将所有符合先定义样式的字符串，以行为单位打印出来。</p>
<p>在1973年，Unix第四版中，grep首次出现在man页面中。</p>
<p>grep实用程序是一个家族，存在很多grep的修改版，例如agrep表示“近似的grep”approximate grep用于模糊字符串搜索，fgrep用于固定样式搜索fixed pattern searches，而egrep用于搜索更复杂的正则表达式语法。fgrep和egrep同grep基本上是一样的程序。Tcgrep是用Perl正则表达式语言重写的grep。</p>
<p>所有grep的修改版都被应用到很多不同的操作系统中。</p>
<h1 id="grep的作用"><a href="#grep的作用" class="headerlink" title="grep的作用"></a>grep的作用</h1><p>Linux grep 命令用于查找文件里符合条件的字符串。</p>
<p>换句话说，grep 命令在给定文件中搜索包含与给定字符串或单词匹配的行。对于开发人员和系统管理员来说，它是 Linux 和类 Unix 系统上最有用的命令之一。</p>
<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</p>
<h1 id="grep语法格式"><a href="#grep语法格式" class="headerlink" title="grep语法格式"></a>grep语法格式</h1><p>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep [OPTIONS] PATTERN [FILE...]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="常见选项"><a href="#常见选项" class="headerlink" title="常见选项"></a>常见选项</h1><p>–color&#x3D;auto 对匹配到的文本着色显示</p>
<p>-m # 匹配#次后停止</p>
<p>-v 显示不被pattern匹配到的行</p>
<p>-i 忽略字符大小写</p>
<p>-n 显示匹配的行号</p>
<p>-c 统计匹配的行数</p>
<p>-o 仅显示匹配到的字符串</p>
<p>-q 静默模式，不输出任何信息</p>
<p>-A # after, 后#行</p>
<p>-B # before, 前#行</p>
<p>-C # context, 前后各#行</p>
<p>-e 实现多个选项间的逻辑or关系,如：grep –e ‘cat ’ -e ‘dog’ file</p>
<p>-w 匹配整个单词</p>
<p>-E 使用ERE，相当于egrep</p>
<p>-F 不支持正则表达式，相当于fgrep</p>
<p>-f file 根据模式文件处理</p>
<p>-r 递归目录，但不处理软链接</p>
<p>-R 递归目录，但处理软链接</p>
<p>-l 打印包含匹配项的文件名，而不是文本行本身，也可用–files-with-matches 选项来指定</p>
<p>-L 相似于-l 选项，但是只是打印不包含匹配项的文件名。也可用–files-without-match 来指定。</p>
<p>-h 应用于多文件搜索，不输出文件名。也可用–no-filename 选项来指定。</p>
<h1 id="grep实例"><a href="#grep实例" class="headerlink" title="grep实例"></a>grep实例</h1><p>这里我将使用Ubuntu18.04进行效果演示。</p>
<h2 id="简单搜索和-l-L的使用"><a href="#简单搜索和-l-L的使用" class="headerlink" title="简单搜索和-l,-L的使用"></a>简单搜索和-l,-L的使用</h2><p>为了更好的探究 grep 程序，让我们创建一些文本文件来搜寻：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin &gt; dirlist-bin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin &gt; dirlist-usr-bin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /sbin &gt; dirlist-sbin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin &gt; dirlist-usr-sbin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> dirlist*.txt</span><br><span class="line">dirlist-bin.txt     dirlist-sbin.txt    dirlist-usr-sbin.txt</span><br><span class="line">dirlist-usr-bin.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-e59933bab98469fb3de636c6614813f2_720w.jpg"><br>够对我们的文件列表执行简单的搜索，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt:bzip2</span><br><span class="line">dirlist-bin.txt:bzip2recover</span><br></pre></td></tr></table></figure>
<p>在这个例子里，grep 程序在所有列出的文件中搜索字符串 bzip，然后找到两个匹配项，其都在文件dirlist-bin.txt 中。如果我们只是对包含匹配项的文件列表，而不是对匹配项本身感兴趣的话，可以指定-l 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -l bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt</span><br></pre></td></tr></table></figure>
<p>相反地，如果我们只想查看不包含匹配项的文件列表，我们可以这样操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -L bzip dirlist*.txt</span><br><span class="line">dirlist-sbin.txt</span><br><span class="line">dirlist-usr-bin.txt</span><br><span class="line">dirlist-usr-sbin.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-221f5f6d8b575379938f509c82e1ab86_720w.jpg"></p>
<h2 id="任何字符"><a href="#任何字符" class="headerlink" title="任何字符"></a>任何字符</h2><p>我们将要查看的第一个元字符是圆点字符，其被用来匹配任意字符。如果我们在正则表达式中包含它， 它将会匹配在此位置的任意一个字符。这里有个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;.zip&#x27;</span> dirlist*.txt</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">prezip-bin</span><br><span class="line">unzip</span><br><span class="line">unzipsfx</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-73c837c9727ac4f5a04d9cc5a327c5f4_720w.jpg"><br>我们在文件中查找包含正则表达式“.zip”的文本行。对于搜索结果，有几点需要注意一下。 注意没有找到这个 zip 程序。这是因为在我们的正则表达式中包含的圆点字符把所要求的匹配项的长度增加到四个字符，并且字符串“zip”只包含三个字符，所以这个 zip 程序不匹配。另外，如果我们的文件列表 中有一些文件的扩展名是.zip，则它们也会成为匹配项，因为文件扩展名中的圆点符号也会被看作是 “任意字符”。</p>
<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>在正则表达式中，插入符号和美元符号被看作是锚点。这意味着正则表达式 只有在文本行的开头或末尾被找到时，才算发生一次匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^zip&#x27;</span> dirlist*.txt</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br><span class="line">zipgrep</span><br><span class="line">zipinfo</span><br><span class="line">zipnote</span><br><span class="line">zipsplit</span><br><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;zip$&#x27;</span> dirlist*.txt</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^zip$&#x27;</span> dirlist*.txt</span><br><span class="line">zip</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-a52d45fcc04272f07ed47e93ddc46fe6_720w.jpg"><br>这里我们分别在文件列表中搜索行首，行尾以及行首和行尾同时包含字符串“zip”（例如，zip 独占一行）的匹配行。 注意正则表达式‘^$’（行首和行尾之间没有字符）会匹配空行。</p>
<h2 id="中括号表达式和字符类"><a href="#中括号表达式和字符类" class="headerlink" title="中括号表达式和字符类"></a>中括号表达式和字符类</h2><p>除了能够在正则表达式中的给定位置匹配任意字符之外，通过使用中括号表达式， 我们也能够从一个指定的字符集合中匹配一个单个的字符。通过中括号表达式，我们能够指定 一个字符集合（包含在不加中括号的情况下会被解释为元字符的字符）来被匹配。在这个例子里，使用了一个两个字符的集合：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[bg]zip&#x27;</span> dirlist*.txt</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gzip</span><br></pre></td></tr></table></figure>
<p>我们匹配包含字符串“bzip”或者“gzip”的任意行。</p>
<p>一个字符集合可能包含任意多个字符，并且元字符被放置到中括号里面后会失去了它们的特殊含义。 然而，在两种情况下，会在中括号表达式中使用元字符，并且有着不同的含义。第一个元字符 是插入字符，其被用来表示否定；第二个是连字符字符，其被用来表示一个字符区域。</p>
<h2 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h2><p>如果在正则表示式中的第一个字符是一个插入字符，则剩余的字符被看作是不会在给定的字符位置出现的 字符集合。通过修改之前的例子，我们试验一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[^bg]zip&#x27;</span> dirlist*.txt</span><br><span class="line">bunzip2</span><br><span class="line">gunzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">prezip-bin</span><br><span class="line">unzip</span><br><span class="line">unzipsfx</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-9668f6f36ee06645cdaa4a8360bff4db_720w.jpg"><br>通过激活否定操作，我们得到一个文件列表，它们的文件名都包含字符串“zip”，并且“zip”的前一个字符 是除了“b”和“g”之外的任意字符。注意文件 zip 没有被发现。一个否定的字符集仍然在给定位置要求一个字符， 但是这个字符必须不是否定字符集的成员。</p>
<p>这个插入字符如果是中括号表达式中的第一个字符的时候，才会唤醒否定功能；否则，它会失去 它的特殊含义，变成字符集中的一个普通字符。</p>
<p>通过激活否定操作，我们得到一个文件列表，它们的文件名都包含字符串“zip”，并且“zip”的前一个字符 是除了“b”和“g”之外的任意字符。注意文件 zip 没有被发现。一个否定的字符集仍然在给定位置要求一个字符， 但是这个字符必须不是否定字符集的成员。</p>
<p>这个插入字符如果是中括号表达式中的第一个字符的时候，才会唤醒否定功能；否则，它会失去它的特殊含义，变成字符集中的一个普通字符。</p>
<h2 id="传统的字符区域"><a href="#传统的字符区域" class="headerlink" title="传统的字符区域"></a>传统的字符区域</h2><p>如果我们想要构建一个正则表达式，它可以在我们的列表中找到每个以大写字母开头的文件，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[ABCDEFGHIJKLMNOPQRSTUVWXZY]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>
<p>这只是一个在正则表达式中输入26个大写字母的问题。但是输入所有字母无疑是非常繁琐且效率低下的，所以有另外一种方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[A-Z]&#x27;</span> dirlist*.txt</span><br><span class="line">MAKEDEV</span><br><span class="line">ControlPanel</span><br><span class="line">GET</span><br><span class="line">HEAD</span><br><span class="line">POST</span><br><span class="line">X</span><br><span class="line">X11</span><br><span class="line">Xorg</span><br><span class="line">MAKEFLOPPIES</span><br><span class="line">NetworkManager</span><br><span class="line">NetworkManagerDispatcher</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-a17b774773e9877036b6d8e3fd5c4b70_720w.jpg"><br>通过使用一个三字符区域，我们能够缩写26个字母。任意字符的区域都能按照这种方式表达，包括多个区域，</p>
<p>比如下面这个表达式就匹配了所有以字母和数字开头的文件名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[A-Za-z0-9]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-5c992da6b6d03bf5d75719a3adc1da37_720w.jpg"><br>在字符区域中，我们看到这个连字符被特殊对待，所以我们怎样在一个正则表达式中包含一个连字符呢？</p>
<p>方法就是使连字符成为表达式中的第一个字符。考虑一下这两个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[A-Z]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-d13a74c027775e94e2b44e6d5fcf802a_720w.jpg"><br>这会匹配包含一个大写字母的文件名。然而：</p>
<p>[me@linuxbox ~]$ grep -h ‘[-AZ]’ dirlist*.txt<br>上面的表达式会匹配包含一个连字符，或一个大写字母“A”，或一个大写字母“Z”的文件名。<br><img src="https://pic3.zhimg.com/80/v2-4bb4ad1611e7f1248eb32f4dcd1cf3a2_720w.jpg"><br>本文部分内容参考自《TLCL》。</p>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>grep</tag>
        <tag>文本编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文本三剑客（2）sed命令的使用</title>
    <url>/archives/ef07d954.html</url>
    <content><![CDATA[<h1 id="sed引言"><a href="#sed引言" class="headerlink" title="sed引言"></a>sed引言</h1><p><strong>sed</strong>（意为流编辑器，源自英语“stream editor”的缩写）是一个使用简单紧凑的编程语言来解析和转换文本Unix实用程序。虽然在某些方面类似于允许脚本编辑的编辑器，但只需对输入进行一次传递即可工作，因此效率更高。但是，它能够过滤管道中的文本，这特别将其与其他类型的编辑器区分开来。</p>
<p>sed由贝尔实验室的李·E·麦克马洪于1973年至1974年开发， 并且现在大多数操作系统都可以使用。 sed基于交互式编辑器ed（“editor”，1971）和早期qed（“quick editor”，1965-66）的脚本功能。sed是最早支持正则表达式的工具之一，至今仍然用于文本处理，特别是用于替换命令。用于纯文本字符串操作和“流编辑”的常用工具还有AWK和Perl 。</p>
<h1 id="sed-工作原理"><a href="#sed-工作原理" class="headerlink" title="sed 工作原理"></a>sed 工作原理</h1><p><img src="https://pic4.zhimg.com/80/v2-ee5564a376f0655b18e9722b2e14baeb_720w.jpg"><br>sed 和 vi 不同，sed是行编辑器。</p>
<p>sed是从文件或管道中读取一行，处理一行，输出一行；再读取一行，再处理一行，再输出一行，直到最后一行。每当处理一行时，把当前处理的行存储在临时缓冲区中，称为<strong>模式空间</strong>（Pattern Space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。一次处理一行的设计模式使得sed性能很高，sed在读取大文件时不会出现卡顿的现象。如果使用vi命令打开几十M上百M的文件，明显会出现有卡顿的现象，这是因为vi命令打开文件是一次性将文件加载到内存，然后再打开。Sed就避免了这种情况，一行一行的处理，打开速度非常快，执行速度也很快。</p>
<h1 id="sed的作用"><a href="#sed的作用" class="headerlink" title="sed的作用"></a>sed的作用</h1><p>sed 是一款非常强大的程序，它能够针对文本流完成相当复杂的编辑任务。它最常用于简单的行任务，而不是长长的脚本。许多用户喜欢使用其它工具，来执行较大的工作。 在这些工具中最著名的是 awk 和 perl。</p>
<p>sed 可依照脚本的指令来处理、编辑文本文件。</p>
<p>sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>
<p>可以实现增删改查，取行、替换、查找等功能。</p>
<h1 id="sed语法格式"><a href="#sed语法格式" class="headerlink" title="sed语法格式"></a>sed语法格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed OPTIONS... [SCRIPT] [INPUTFILE...]</span><br></pre></td></tr></table></figure>

<h1 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-e &lt;script&gt;或--expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。</span><br><span class="line">-f &lt;script文件&gt;或--file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</span><br></pre></td></tr></table></figure>
<p>-h或–help 显示帮助。<br>-n或–quiet或–silent 仅显示script处理后的结果。<br>-V或–version 显示版本信息。  </p>
<h1 id="动作说明："><a href="#动作说明：" class="headerlink" title="动作说明："></a>动作说明：</h1><p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除，d 后面通常不接任何字串；<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行<br>s ：取代，查找替换,支持使用其它分隔符，可以是其它形式：s@@@，s### 替换修饰符<br>g ：行内全局替换</p>
<h1 id="sed实例"><a href="#sed实例" class="headerlink" title="sed实例"></a>sed实例</h1><p>这里我将使用Ubuntu18.04进行效果演示。</p>
<p>为了更好的探究 sed 程序，让我们创建一个包含以下数据的名为distros.txt文本文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fedora         10       11/25/2008</span><br><span class="line">Ubuntu         8.04     04/24/2008</span><br><span class="line">SUSE         10.3     10/04/2007</span><br><span class="line">Fedora         8        11/08/2007</span><br><span class="line">Ubuntu         6.10     10/26/2006</span><br><span class="line">Fedora         7        05/31/2007</span><br><span class="line">SUSE         11.0     06/19/2008</span><br><span class="line">Ubuntu         7.10     10/18/2007</span><br><span class="line">Ubuntu         7.04     04/19/2007</span><br><span class="line">Fedora         6        10/24/2006</span><br><span class="line">Fedora         9        05/13/2008</span><br><span class="line">Ubuntu         6.06     06/01/2006</span><br><span class="line">SUSE         10.2     12/07/2006</span><br><span class="line">Ubuntu         8.10     10/30/2008</span><br><span class="line">Fedora         5        03/20/2006</span><br><span class="line">SUSE         10.1     05/11/2006</span><br></pre></td></tr></table></figure>
<h2 id="sed简单输出"><a href="#sed简单输出" class="headerlink" title="sed简单输出"></a>sed简单输出</h2><p>通过 distros.txt 文件，我们将演示sed的各种用法。</p>
<p>首先，输出distros.txt文件的1-5行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;1,5p&#x27;</span> distros.txt</span><br><span class="line">SUSE           10.2     12/07/2006</span><br><span class="line">Fedora         10       11/25/2008</span><br><span class="line">SUSE           11.0     06/19/2008</span><br><span class="line">Ubuntu         8.04     04/24/2008</span><br><span class="line">Fedora         8        11/08/2007</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-b5e76901ff2f6e31815901d9e811cba9_720w.jpg"><br>在这个例子中，我们打印出一系列的文本行，开始于第一行，直到第五行。为此，我们使用 p 命令， 其就是简单地把匹配的文本行打印出来。然而为了高效，我们必须包含选项 -n（不自动打印选项）， 让 sed 不要默认地打印每一行。</p>
<p>sed默认显示所有内容，所以不加-n的话，如下图所示，会把目标行和所有内容都显示出来。<br><img src="https://pic3.zhimg.com/80/v2-37f017cd0aa45565ffe51f1ae7a764ae_720w.jpg"></p>
<h2 id="sed查询"><a href="#sed查询" class="headerlink" title="sed查询"></a>sed查询</h2><p>下一步，我们将试用一下正则表达式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;/SUSE/p&#x27;</span> distros.txt</span><br><span class="line">SUSE         10.2     12/07/2006</span><br><span class="line">SUSE         11.0     06/19/2008</span><br><span class="line">SUSE         10.3     10/04/2007</span><br><span class="line">SUSE         10.1     05/11/2006</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-ff03bd19c7c885739849e0e349965cf6_720w.jpg"><br>通过包含由斜杠界定的正则表达式 ‘&#x2F;SUSE&#x2F;’，我们能够孤立出包含它的文本行，和 grep 程序的功能是相同的。</p>
<p>试着否定上面的操作，通过给这个地址添加一个感叹号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;/SUSE/!p&#x27;</span> distros.txt</span><br><span class="line">Fedora         10       11/25/2008</span><br><span class="line">Ubuntu         8.04     04/24/2008</span><br><span class="line">Fedora         8        11/08/2007</span><br><span class="line">Ubuntu         6.10     10/26/2006</span><br><span class="line">Fedora         7        05/31/2007</span><br><span class="line">Ubuntu         7.10     10/18/2007</span><br><span class="line">Ubuntu         7.04     04/19/2007</span><br><span class="line">Fedora         6        10/24/2006</span><br><span class="line">Fedora         9        05/13/2008</span><br><span class="line">Ubuntu         6.06     06/01/2006</span><br><span class="line">Ubuntu         8.10     10/30/2008</span><br><span class="line">Fedora         5        03/20/2006</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-657275ae8e21f36a956078f047e42f34_720w.jpg"><br>这里我们看到期望的结果：输出了文件中所有的文本行，除了那些匹配这个正则表达式的文本行。</p>
<p>目前为止，我们已经知道了两个 sed 的编辑命令，s 和 p。</p>
<h2 id="sed编辑修改"><a href="#sed编辑修改" class="headerlink" title="sed编辑修改"></a>sed编辑修改</h2><p>到目前为止，这个 s 命令是最常使用的编辑命令。我们将仅仅演示一些它的功能，通过编辑我们的 distros.txt 文件。我们以前讨论过 distros.txt 文件中的日期字段不是“友好地计算机”模式。 文件中的日期格式是 MM&#x2F;DD&#x2F;YYYY，但如果格式是 YYYY-MM-DD 会更好一些（利于排序）。手动修改 日期格式不仅浪费时间而且易出错，但是有了 sed，只需一步就能完成修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed <span class="string">&#x27;s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/&#x27;</span> distros.txt</span><br><span class="line"></span><br><span class="line">SUSE           10.2     2006-12-07</span><br><span class="line">Fedora         10       2008-11-25</span><br><span class="line">SUSE           11.0     2008-06-19</span><br><span class="line">Ubuntu         8.04     2008-04-24</span><br><span class="line">Fedora         8        2007-11-08</span><br><span class="line">SUSE           10.3     2007-10-04</span><br><span class="line">Ubuntu         6.10     2006-10-26</span><br><span class="line">Fedora         7        2007-05-31</span><br><span class="line">Ubuntu         7.10     2007-10-18</span><br><span class="line">Ubuntu         7.04     2007-04-19</span><br><span class="line">SUSE           10.1     2006-05-11</span><br><span class="line">Fedora         6        2006-10-24</span><br><span class="line">Fedora         9        2008-05-13</span><br><span class="line">Ubuntu         6.06     2006-06-01</span><br><span class="line">Ubuntu         8.10     2008-10-30</span><br><span class="line">Fedora         5        2006-03-20</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-06814637d7798a93654cfcec1b2feaee_720w.jpg"><br>这个命令看起来很丑陋。但是它起作用了。仅用一步，我们就更改了文件中的日期格式。 它也是一个关于为什么有时候会开玩笑地把正则表达式称为是“只写”媒介的完美的例子。我们 能写正则表达式，但是有时候我们不能读它们。在我们恐惧地忍不住要逃离此命令之前，让我们看一下 怎样来构建它。首先，我们知道此命令有这样一个基本的结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/regexp/replacement/&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure>
<p>我们下一步是要弄明白一个正则表达式将要孤立出日期。因为日期是 MM&#x2F;DD&#x2F;YYYY 格式，并且 出现在文本行的末尾，我们可以使用这样的表达式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0-9]&#123;2&#125;/[0-9]&#123;2&#125;/[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure>
<p>此表达式匹配两位数字，一个斜杠，两位数字，一个斜杠，四位数字，以及行尾。如此关心regexp， 那么replacement又怎样呢？为了解决此问题，我们必须介绍一个正则表达式的新功能，它出现 在一些使用 BRE 的应用程序中。这个功能叫做逆参照，像这样工作：如果序列\n出现在replacement中 ，这里 n 是指从 1 到 9 的数字，则这个序列指的是在前面正则表达式中相对应的子表达式。为了 创建这个子表达式，我们简单地把它们用圆括号括起来，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">([0-9]&#123;2&#125;)/([0-9]&#123;2&#125;)/([0-9]&#123;4&#125;)$</span><br></pre></td></tr></table></figure>
<p>现在我们有了三个子表达式。第一个表达式包含月份，第二个包含某月中的某天，以及第三个包含年份。 现在我们就可以构建replacement，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\3-\1-\2</span><br></pre></td></tr></table></figure>
<p>此表达式给出了年份，一个短划线，月份，一个短划线，和某天。</p>
<p>现在我们的命令看起来像下面这样：</p>
<p>sed ‘s&#x2F;([0-9]{2})&#x2F;([0-9]{2})&#x2F;([0-9]{4})$&#x2F;\3-\1-\2&#x2F;‘ distros.txt<br>我们还有两个问题。第一个是当 sed 试图解释这个 s 命令的时候在我们表达式中额外的斜杠将会使 sed 迷惑。 第二个是由于sed默认情况下只接受基本的正则表达式，在表达式中的几个字符会 被当作文字字面值，而不是元字符。我们能够通过反斜杠的自由应用来转义令人不快的字符解决这两个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure>

<h2 id="sed替换"><a href="#sed替换" class="headerlink" title="sed替换"></a>sed替换</h2><p>s 命令的另一个功能是使用可选标志，其跟随替代字符串。一个最重要的可选标志是 g 标志，其 指示 sed 对某个文本行全范围地执行查找和替代操作，不仅仅是对第一个实例，这是默认行为。 这里有个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;aaabbbccc&quot;</span> | sed <span class="string">&#x27;s/b/B/&#x27;</span></span><br><span class="line">aaaBbbccc</span><br></pre></td></tr></table></figure>
<p>我们看到虽然执行了替换操作，但是只针对第一个字母 “b” 实例，然而剩余的实例没有更改。通过添加 g 标志， 我们能够更改所有的实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;aaabbbccc&quot;</span> | sed <span class="string">&#x27;s/b/B/g&#x27;</span></span><br><span class="line">aaaBBBccc</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-943f6225d54eb4c480aef90c6b82200f_720w.jpg"></p>
<h2 id="sed脚本"><a href="#sed脚本" class="headerlink" title="sed脚本"></a>sed脚本</h2><p>目前为止，通过命令行我们只让 sed 执行单个命令。使用-f 选项，也有可能在一个脚本文件中构建更加复杂的命令。 为了演示，我们将使用 sed 和 distros.txt 文件来生成一个报告。我们的报告以开头标题，修改过的日期，以及 大写的发行版名称为特征。为此，我们需要编写一个脚本，所以我们将打开文本编辑器，然后输入以下文字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sed script to produce Linux distributions report</span></span><br><span class="line"></span><br><span class="line">1 i\</span><br><span class="line">\</span><br><span class="line">Linux Distributions Report\</span><br><span class="line"></span><br><span class="line">s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</span><br></pre></td></tr></table></figure>
<p>我们将把 sed 脚本保存为 distros.sed 文件，然后像这样运行它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -f distros.sed distros.txt</span><br><span class="line">Linux Distributions Report</span><br><span class="line">SUSE	10.2	2006-12-07</span><br><span class="line">FEDORA	10	    2008-11-25</span><br><span class="line">SUSE	11.0	2008-06-19</span><br><span class="line">UBUNTU	8.04	2008-04-24</span><br><span class="line">FEDORA	8	    2007-11-08</span><br><span class="line">SUSE	10.3	2007-10-04</span><br><span class="line">UBUNTU	6.10	2006-10-26</span><br><span class="line">FEDORA	7	    2007-05-31</span><br><span class="line">UBUNTU	7.10	2007-10-18</span><br><span class="line">UBUNTU	7.04	2007-04-19</span><br><span class="line">SUSE	10.1	2006-05-11</span><br><span class="line">FEDORA	6	    2006-10-24</span><br><span class="line">FEDORA	9	    2008-05-13</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-607a1decdae2246716fd6c082c9146a7_720w.jpg"><br>正如我们所见，我们的脚本文件产生了期望的结果，但是它是如何做到的呢？让我们再看一下我们的脚本文件。 我们将使用 cat 来给每行文本编号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -n distros.sed</span><br><span class="line">1 <span class="comment"># sed script to produce Linux distributions report</span></span><br><span class="line">2</span><br><span class="line">3 1 i\</span><br><span class="line">4 \</span><br><span class="line">5 Linux Distributions Report\</span><br><span class="line">6</span><br><span class="line">7 s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">8 y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-0415afdc86a25eb61b3489e56db4fe01_720w.jpg"></p>
<h3 id="脚本文件详解："><a href="#脚本文件详解：" class="headerlink" title="脚本文件详解："></a>脚本文件详解：</h3><p>我们脚本文件的<strong>第一行</strong>是一条注释。如同 Linux 系统中的许多配置文件和编程语言一样，注释以#字符开始， 然后是文本注释。注释可以被放到脚本中的任意地方（虽然不在命令本身之中），且对任何可能需要理解和／或维护脚本的人们都很有帮助。</p>
<p><strong>第二行</strong>是一个空行。正如注释一样，添加空白行是为了提高程序的可读性。</p>
<p>许多 sed 命令支持行地址。这些行地址被用来指定对输入文本的哪一行执行操作。行地址可能被 表示为单独的行号，行号范围，以及特殊的行号“$”，它表示输入文本的最后一行。</p>
<p><strong>从第三行到第六行</strong>所包含地文本要被插入到地址 1 处，也就是输入文本的第一行中。这个 i 命令之后是反斜杠回车符，来产生一个转义的回车符，或者就是所谓的连行符。这个序列能够 被用在许多环境下，包括 shell 脚本，从而允许把回车符嵌入到文本流中，而没有通知解释器（在这是指 sed 解释器）已经到达了文本行的末尾。这个 i 命令，同样地，命令 a（追加文本， 而不是插入文本）和 c（取代文本）命令都允许多个文本行，只要每个文本行，除了最后一行，以一个 连行符结束。实际上，脚本的第六行是插入文本的末尾，它以一个普通的回车符结尾，而不是一个连行符，通知解释器 i 命令结束了。</p>
<p>注意：一个连行符由一个反斜杠字符其后紧跟一个回车符组成。它们之间不允许有空白字符。</p>
<p><strong>第七行</strong>是我们的查找和替代命令。因为命令之前没有添加地址，所以输入流中的每一行文本 都得服从它的操作。</p>
<p><strong>第八行</strong>执行小写字母到大写字母的字符替换操作。注意不同于 tr 命令，这个 sed 中的 y 命令不 支持字符区域（例如，[a-z]），也不支持 POSIX 字符集。再说一次，因为 y 命令之前不带地址， 所以它会操作输入流的每一行。</p>
<p>本文部分内容参考自《TLCL》。</p>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文本编辑器</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文本三剑客（3）awk命令的使用</title>
    <url>/archives/9edfe48f.html</url>
    <content><![CDATA[<h1 id="AWK引言"><a href="#AWK引言" class="headerlink" title="AWK引言"></a>AWK引言</h1><p>AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。</p>
<p>这种编程及数据操作语言（其名称得自于它的创始人Alfred Aho，Peter Weinberger, 和 Brian Kernighan姓氏的首个字母）的最大功能取决于一个人所拥有的知识。AWK提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。</p>
<p>实际上AWK的确拥有自己的语言：AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。GAWK是AWK的GNU版本，与AWK和NAWK完全兼容。NAWK即New awk，是AT &amp; T 实验室的AWK的升级版。</p>
<p>最简单地说，AWK是一种用于处理文本的编程语言工具。AWK在很多方面类似于Unix shell编程语言，尽管AWK具有完全属于其本身的语法。它的设计思想来源于SNOBOL4、sed、Marc Rochkind设计的有效性语言、语言工具yacc和lex，当然还从C语言中获取了一些优秀的思想。</p>
<h1 id="AWK程序结构"><a href="#AWK程序结构" class="headerlink" title="AWK程序结构"></a>AWK程序结构</h1><p><img src="https://pic2.zhimg.com/80/v2-4c93fab6268f7f1819133d36d550ca8d_720w.jpg"><br>在最初创造AWK时，其目的是用于文本处理，并且这种语言的基础是，只要在输入数据中有模式匹配，就执行一系列指令。该实用工具扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。</p>
<p>具体过程如下：</p>
<ol>
<li><p>第一步：执行BEGIN{action;… }语句块中的语句。</p>
</li>
<li><p>第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ action;… }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。</p>
</li>
<li><p>第三步：当读至输入流末尾时，执行END{action;…}语句块。</p>
</li>
</ol>
<p>BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p>
<p>END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p>
<p>pattern语句块中的通用命令是最重要的部分，也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p>
<h1 id="AWK的作用"><a href="#AWK的作用" class="headerlink" title="AWK的作用"></a>AWK的作用</h1><p>AWK是一种处理文本文件的语言。它将文件作为记录序列处理。在一般情况下，文件内容的每行都是一个记录。每行内容都会被分割成一系列的域，因此，我们可以认为一行的第一个词为第一个域，第二个词为第二个，以此类推。AWK程序是由一些处理特定模式的语句块构成的。AWK一次可以读取一个输入行。对每个输入行，AWK解释器会判断它是否符合程序中出现的各个模式，并执行符合的模式所对应的动作。</p>
<h1 id="AWK的语法格式"><a href="#AWK的语法格式" class="headerlink" title="AWK的语法格式"></a>AWK的语法格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [options]   <span class="string">&#x27;program&#x27;</span>     var=value   file… </span><br><span class="line">awk [options]   -f programfile    var=value  file…</span><br></pre></td></tr></table></figure>
<p>分割符、域和记录<br>由分隔符分隔的字段（列column,域field）标记$1,$2…$n称为域标识，$0为所有域，注意：和shell中变量$符含义不同<br>文件的每一行称为记录record<br>如果省略action，则默认执行 print ​$0 的操作<br>常用的action分类<br>output statements：print,printf<br>Expressions：算术，比较表达式等<br>Compound statements：组合语句<br>Control statements：if, while等<br>input statements    </p>
<h1 id="awk控制语句"><a href="#awk控制语句" class="headerlink" title="awk控制语句"></a>awk控制语句</h1><p>{ statements;… } 组合语句<br>if(condition) {statements;…}<br>if(condition) {statements;…} else {statements;…}<br>while(conditon) {statments;…}<br>do {statements;…} while(condition)<br>for(expr1;expr2;expr3) {statements;…}<br>break<br>continue<br>exit    </p>
<h1 id="选项参数说明："><a href="#选项参数说明：" class="headerlink" title="选项参数说明："></a>选项参数说明：</h1><p>-F fs or –field-separator fs<br>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。<br>-v var&#x3D;value or –asign var&#x3D;value<br>赋值一个用户定义变量。<br>-f scripfile or –file scriptfile<br>从脚本文件中读取awk命令。<br>-mf nnn and -mr nnn<br>对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。<br>-W compact or –compat, -W traditional or –traditional<br>在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。<br>-W copyleft or –copyleft, -W copyright or –copyright<br>打印简短的版权信息。<br>-W help or –help, -W usage or –usage<br>打印全部awk选项和每个选项的简短说明。<br>-W lint or –lint<br>打印不能向传统unix平台移植的结构的警告。<br>-W lint-old or –lint-old<br>打印关于不能向传统unix平台移植的结构的警告。<br>-W posix<br>打开兼容模式。但有以下限制，不识别：&#x2F;x、函数关键字、func、换码序列以及当fs是一个空格时， 将新行作为一个域分隔符；操作符<strong>和</strong>&#x3D;不能代替^和^&#x3D;；fflush无效。<br>-W re-interval or –re-inerval<br>允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。<br>-W source program-text or –source program-text<br>使用program-text作为源代码，可与-f命令混用。<br>-W version or –version<br>打印bug报告信息的版本。</p>
<h2 id="动作-print"><a href="#动作-print" class="headerlink" title="动作 print"></a>动作 print</h2><p>格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> item1, item2, ...</span><br></pre></td></tr></table></figure>
<p>说明：  </p>
<p>逗号分隔符<br>输出item可以字符串，也可是数值；当前记录的字段、变量或awk的表达式<br>如省略item，相当于print $0  </p>
<h1 id="AWK实例"><a href="#AWK实例" class="headerlink" title="AWK实例"></a>AWK实例</h1><p>这里我将使用Ubuntu18.04进行效果演示。</p>
<p><a href="https://raidenxe.github.io/archives/ef07d954.html">Linux 文本三剑客（2）sed命令的使用</a></p>
<p>为了更好的探究 awk 程序，让我们创建一个包含以下数据的名为distros.txt文本文件（即我介绍sed命令的distros.txt文件）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fedora         10       11/25/2008</span><br><span class="line">Ubuntu         8.04     04/24/2008</span><br><span class="line">SUSE         10.3     10/04/2007</span><br><span class="line">Fedora         8        11/08/2007</span><br><span class="line">Ubuntu         6.10     10/26/2006</span><br><span class="line">Fedora         7        05/31/2007</span><br><span class="line">SUSE         11.0     06/19/2008</span><br><span class="line">Ubuntu         7.10     10/18/2007</span><br><span class="line">Ubuntu         7.04     04/19/2007</span><br><span class="line">Fedora         6        10/24/2006</span><br><span class="line">Fedora         9        05/13/2008</span><br><span class="line">Ubuntu         6.06     06/01/2006</span><br><span class="line">SUSE         10.2     12/07/2006</span><br><span class="line">Ubuntu         8.10     10/30/2008</span><br><span class="line">Fedora         5        03/20/2006</span><br><span class="line">SUSE         10.1     05/11/2006</span><br></pre></td></tr></table></figure>
<h2 id="AWK取行"><a href="#AWK取行" class="headerlink" title="AWK取行"></a>AWK取行</h2><p>awk根据行号，取出某一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR==2&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-e5edeef80536a55c055f8bf5b78100fb_720w.jpg"><br>这里取出的是第二行，注意是NR&#x3D;&#x3D;’行号’。NR即Number of Record，记录号（行号），是awk的内置变量。</p>
<p>下面试试取出2-5行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR==2,NR==5&#x27;</span> distros.txt </span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-98ac345942c4f81bee9b2f5469ff3e61_720w.jpg"></p>
<p>显示文件的最后一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;END&#123;print $0&#125;&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-4e288e84f699d800660efc768d0ab0a2_720w.jpg"></p>
<h2 id="AWK模糊查询"><a href="#AWK模糊查询" class="headerlink" title="AWK模糊查询"></a>AWK模糊查询</h2><p>awk过滤出含有Ubuntu的行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;/Ubuntu/&#x27;</span> distros.txt </span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-4e127f282bffb558ce2b076265e24ff0_720w.jpg"><br>awk过滤出含有Ubuntu和SUSE的行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;/Ubuntu|SUSE/&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-8aedde5c585b2cd1fbf1d8d7ad31ea6d_720w.jpg"></p>
<h2 id="AWK取列"><a href="#AWK取列" class="headerlink" title="AWK取列"></a>AWK取列</h2><h3 id="awk根据列号，取出某一列"><a href="#awk根据列号，取出某一列" class="headerlink" title="awk根据列号，取出某一列"></a>awk根据列号，取出某一列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-ff636360024689e79e5a0b8efcf22ee5_720w.jpg"></p>
<p>这里取出的是第一列。</p>
<h3 id="awk取最后一列"><a href="#awk取最后一列" class="headerlink" title="awk取最后一列"></a>awk取最后一列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-4f18d644a5132aef4b8bace3a641b92d_720w.jpg"></p>
<p>NF即Number of Field，每行有多少列，同样是awk内置变量。</p>
<h3 id="awk取多列"><a href="#awk取多列" class="headerlink" title="awk取多列"></a>awk取多列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1,$NF&#125;&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-b8eb9745e3569b03e401b9e22f5f71fc_720w.jpg"></p>
<p>注意列号之间以“，”相隔。</p>
<h3 id="awk取多列自动对齐"><a href="#awk取多列自动对齐" class="headerlink" title="awk取多列自动对齐"></a>awk取多列自动对齐</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1,$2,$NF&#125;&#x27;</span> distros.txt |column -t</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-8f31d2dbfb10bfed18114a45aebac721_720w.jpg"><br>awk指定分隔符</p>
<p>这里新建一个以“，”为分隔符的名为distros1.txt文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fedora,10,11/25/2008</span><br><span class="line">Ubuntu,8.04,04/24/2008</span><br><span class="line">SUSE,10.3,10/04/2007</span><br><span class="line">Fedora,8,11/08/2007</span><br></pre></td></tr></table></figure>
<p>awk -F #-F相当于内置变量FS, 指定分割字符</p>
<h3 id="awk以“，”为分隔符取第一二列"><a href="#awk以“，”为分隔符取第一二列" class="headerlink" title="awk以“，”为分隔符取第一二列"></a>awk以“，”为分隔符取第一二列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F, <span class="string">&#x27;&#123;print $1,$2&#125;&#x27;</span>  distros1.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-00ae1ac4e76adae65bc61d443e62676b_720w.jpg"></p>
<h1 id="AWK精确过滤"><a href="#AWK精确过滤" class="headerlink" title="AWK精确过滤"></a>AWK精确过滤</h1><p>awk过滤出第3列包含数字1的列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;$3 ~ /^1/&#x27;</span> distros.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-f98cfb62f887c28adfb7e089d3ed1913_720w.jpg"></p>
<p>至此Linux文本三剑客的基本使用方法已经全部介绍完毕，有兴趣可以浏览我之前的两篇文章，希望能对你有所帮助。</p>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文本编辑器</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下的fork和exec函数</title>
    <url>/archives/90acc1af.html</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>多线程程序设计的概念早在六十年代就被提出，但直到八十年代中期，Unix系统中才引入多线程机制，如今，由于自身的许多优点，多线程编程已经得到了广泛的应用。</p>
<p>fork函数是Unix系统最杰出的成就之一，它是七十年代UNIX早期的开发者经过长期在理论和实践上的艰苦探索后取得的成果，一方面，它使操作系统在进程管理上付出了最小的代价，另一方面，又为程序员提供了一个简洁明了的多进程方法。</p>
<h1 id="Linux下进程的结构"><a href="#Linux下进程的结构" class="headerlink" title="Linux下进程的结构"></a>Linux下进程的结构</h1><p>Linux下一个进程在内存里有三部分的数据，就是”代码段”、”堆栈段”和”数据段”。其实学过汇编语言的人一定知道，一般的CPU都有上述三种段寄存器，以方便操作系统的运行。这三个部分也是构成一个完整的执行序列的必要的部分。</p>
<p>“代码段”，顾名思义，就是存放了程序代码的数据，假如机器中有数个进程运行相同的一个程序，那么它们就可以使用相同的代码段。”堆栈段”存放的就是子程序的返回地址、子程序的参数以及程序的局部变量。而数据段则存放程序的全局变量，常数以及动态数据分配的数据空间（比如用malloc之类的函数取得的空间）。这其中有许多细节问题，这里限于篇幅就不多介绍了。系统如果同时运行数个相同的程序，它们之间就不能使用同一个堆栈段和数据段。　　</p>
<h1 id="Linux下的进程控制"><a href="#Linux下的进程控制" class="headerlink" title="Linux下的进程控制"></a>Linux下的进程控制</h1><p><img src="https://pic4.zhimg.com/80/v2-eacfccfbb95739f120d80f78582b332f_720w.jpg"><br>在传统的Unix环境下，有两个基本的操作用于创建和修改进程：</p>
<p>函数fork( )用来创建一个新的进程，该进程几乎是当前进程的一个完全拷贝；</p>
<p>函数族exec( )用来启动另外的进程以取代当前运行的进程。</p>
<p>Linux的进程控制和传统的Unix进程控制基本一致，只在一些细节的地方有些区别，例如在Linux系统中调用vfork和fork完全相同，而在有些版本的Unix系统中，vfork调用有不同的功能。</p>
<p>fork函数（包括有些系统可能提供的它的各种变体）是Unix中派生新进程的唯一方法。fork函数也是编写并发服务器程序的基础之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># fork函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">include &lt;unistd.h&gt;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> ;<span class="comment">// 返回:在子进程中为o，在父进程中为子进程ID，若出错则为-1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-1fe39319fb80fc6891b8ee5522614f6b_720w.jpg"><br>fork在英文中是”分叉”的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork，就产生了另一个进程，于是进程就”分叉”了，所以这个名字取得很形象。</p>
<h2 id="fork的返回值"><a href="#fork的返回值" class="headerlink" title="fork的返回值"></a>fork的返回值</h2><p>如果你以前从未接触过该函数，那么理解fork最困难之处在于调用它一次，它却返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号，在子进程又返回一次，返回值为0。</p>
<p>因此，返回值本身告知当前进程是子进程还是父进程。</p>
<p>fork在子进程返回0，而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用getpid取得父进程的进程ID。相反，父进程可以有许多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。</p>
<p>父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。我们将看到网络服务器利用了这个特性:父进程调用accept之后调用fork。所接受的已连接套接字随后就在父进程与子进程之间共享。通常情况下，子进程接着读写这个己连接套接字，父进程则关闭这个已连接套接字。</p>
<h2 id="fork的两个典型用法"><a href="#fork的两个典型用法" class="headerlink" title="fork的两个典型用法"></a>fork的两个典型用法</h2><p>(1) 一个进程创建一个自身的副本,这样每个副本都可以在另一个副本执行其他任务的同时处理各自的某个操作。这是网络服务器的典型用法。</p>
<p>(2) 一个进程想要执行另一个程序。既然创建新进程的唯一办法是调用fork，该进程于是首先调用fork创建一个自身的副本，然后其中一个副本（通常为子进程）调用exec把自身替换成新的程序。这是诸如shell之类程序的典型用法。</p>
<h2 id="用法例外"><a href="#用法例外" class="headerlink" title="用法例外"></a>用法例外</h2><p>fork() 通过复制调用进程来创建一个新进程，新进程称为子进程，是调用进程（称为父进程）的完全副本，但以下情况除外：</p>
<p>1.子进程有自己唯一的进程 ID，并且这个 PID 不匹配任何现有进程组的 ID。</p>
<p>2.子进程的父进程 ID 与父进程 ID 相同。</p>
<p>3.子进程不会继承其父进程的内存锁和信号量调整。</p>
<p>4.子代不会从其父代继承未完成的异步 I&#x2F;O 操作，也不会从其父代继承任何异步 I&#x2F;O 上下文。</p>
<h1 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec( )函数族"></a>exec( )函数族</h1><p>下面我们来看看一个进程如何来启动另一个程序的执行。</p>
<p>在Linux中要使用exec函数族。</p>
<h2 id="exec-函数族的作用"><a href="#exec-函数族的作用" class="headerlink" title="exec( )函数族的作用"></a>exec( )函数族的作用</h2><p><img src="https://pic1.zhimg.com/80/v2-e31f805cf04b4d3973aa080f9e2bce68_720w.jpg"><br>exec把当前进程映像替换成新的程序文件，而且该新程序通常从main函数开始执行。进程ID并不改变。我们称调用exec的进程为调用进程(calling process)，称新执行的程序为新程序(new program)。</p>
<h2 id="6个exec函数族"><a href="#6个exec函数族" class="headerlink" title="6个exec函数族"></a>6个exec函数族</h2><p>系统调用execve（）对当前进程进行替换，替换者为一个指定的程序，其参数包括文件名（filename）、参数列表（argv）以及环境变量（envp）。exec函数族当然不止一个，但它们大致相同，在 Linux中，它们分别是：execl，execlp，execle，execv，execve和execvp。</p>
<h2 id="6个exec函数之间的区别"><a href="#6个exec函数之间的区别" class="headerlink" title="6个exec函数之间的区别:"></a>6个exec函数之间的区别:</h2><p>(a）待执行的程序文件是由文件名(filename）还是由路径名（pathname）指定;</p>
<p>(b）新程序的参数是一一列出还是由一个指针数组来引用;</p>
<p>(c）把调用进程的环境传递给新程序还是给新程序指定新的环境。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname，<span class="type">const</span> <span class="type">char</span> *arg0， ... <span class="comment">/* (char *) 0*/</span> )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname，<span class="type">char</span> *<span class="type">const</span> *argv[ ] )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname，<span class="type">const</span> <span class="type">char</span> *arg0, ...</span></span><br><span class="line"><span class="params"><span class="comment">/*( char * ) 0, char *const envp [ ] */</span>)</span> ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname，<span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp [])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename，<span class="type">const</span> <span class="type">char</span> *arg0，... <span class="comment">/* (char *) 0*/</span> )</span>;</span><br><span class="line"><span class="type">int</span>. execvp(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">char</span> *<span class="type">const</span> argv[] );</span><br><span class="line"><span class="comment">//均返回:若成功则不返回，若出错则为-1</span></span><br></pre></td></tr></table></figure>

<p>这些函数只在出错时才返回到调用者。否则，控制将被传递给新程序的起始点，通常就是main函数。</p>
<p>这6个函数间的关系如图4-12所示。一般来说，只有execve是内核中的系统调用，其他5个都是调用execve的库函数。<br><img src="https://pic2.zhimg.com/80/v2-14fd9241c4671aa8c057c7c3e33da765_720w.jpg"><br>(1) 上面那行的3个函数把新程序的每个参数字符串指定成exec的一个独立参数，并以一个空指针结束可变数量的这些参数。下面那行的3个函数都有一个作为exec参数的argv数组，其中含有指向新程序各个参数字符串的所有指针。既然没有指定参数字符串的数目，这个argv数组必须含有一个用于指定其末尾的空指针。</p>
<p>(2) 左列2个函数指定一个filename参数。exec将使用当前的PATH环境变量把该文件名参数转换为一个路径名。然而一旦这2个函数的filename参数中含有一个斜杠（&#x2F;)，就不再使用PATH环境变量。右两列4个函数指定一个全限定的pathname参数。</p>
<p>(3) 左两列4个函数不显式指定一个环境指针。相反，它们使用外部变量environ的当前值来构造一个传递给新程序的环境列表。右列2个函数显式指定一个环境列表，其envp指针数组必须以一个空指针结束。</p>
<p>进程在调用exec之前打开着的描述符通常跨exec继续保持打开。我们使用限定词“通常”是因为本默认行为可以使用fcntl设置FD_CLOEXEc描述符标志禁止掉。inetd服务器就利用了这个特性。</p>
<h1 id="fork和exec代码示例："><a href="#fork和exec代码示例：" class="headerlink" title="fork和exec代码示例："></a>fork和exec代码示例：</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C程序来说明fork（）的用法&amp;</span></span><br><span class="line"><span class="comment">//exec（）系统调用以创建进程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pid == -1 表示发生了错误</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t fork, error occured\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pid == 0 表示创建了子进程</span></span><br><span class="line">	<span class="comment">// getpid() 返回调用进程的进程id</span></span><br><span class="line">	<span class="comment">// 返回子进程的进程id</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child process, pid = %u\n&quot;</span>,getpid());</span><br><span class="line">	<span class="comment">// 返回子进程的父进程，即父进程本身</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent of child process, pid = %u\n&quot;</span>,getppid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// argv list第一个参数应该指向</span></span><br><span class="line">	<span class="comment">// 与正在执行的文件关联的文件名</span></span><br><span class="line">	<span class="comment">// 数组指针必须以NULL结尾</span></span><br><span class="line">	<span class="comment">// 指针</span></span><br><span class="line">	<span class="type">char</span> * argv_list[] = &#123;<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-lart&quot;</span>,<span class="string">&quot;/home&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// execv（）仅在发生错误时返回。</span></span><br><span class="line">	<span class="comment">// 返回值为-1</span></span><br><span class="line">	execv(<span class="string">&quot;ls&quot;</span>,argv_list);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">// 为pid返回一个正数</span></span><br><span class="line">	<span class="comment">// 父进程</span></span><br><span class="line">	<span class="comment">// getppid（）返回进程的父进程id</span></span><br><span class="line">	<span class="comment">// 调用进程</span></span><br><span class="line">        <span class="comment">// 返回父进程ID的父进程</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Parent Of parent process, pid = %u\n&quot;</span>,getppid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent process, pid = %u\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 父进程对子进程调用waitpid（）</span></span><br><span class="line">		<span class="comment">// waitpid（）系统调用暂停</span></span><br><span class="line">		<span class="comment">// 调用进程直到pid指定的子进程</span></span><br><span class="line">		<span class="comment">// 状态改变</span></span><br><span class="line">		<span class="comment">// 有关所有标志或选项，请参见wait（）手册</span></span><br><span class="line">		<span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (WIFEXITED(status) &amp;&amp; !WEXITSTATUS(status))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;program execution successful\n&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (WIFEXITED(status) &amp;&amp; WEXITSTATUS(status)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (WEXITSTATUS(status) == <span class="number">127</span>) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// execv failed</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;execv failed\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;program terminated normally,&quot;</span></span><br><span class="line">					<span class="string">&quot; but returned a non-zero status\n&quot;</span>);			</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;program didn&#x27;t terminate normally\n&quot;</span>);		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// waitpid() failed</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;waitpid() failed\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文部分内容参考自《UNIX网络编程卷1套接字联网API》。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/archives/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>常用Linux命令整理</title>
    <url>/archives/aba2a9fd.html</url>
    <content><![CDATA[<p>一、 Linux 系统中的目录</p>
<p>“一切皆是文件”是 Unix&#x2F;Linux 的基本哲学之一,了解Linux的目录结构能让我们更得心应手地去使用相关命令。<br><img src="https://pic2.zhimg.com/80/v2-0b1560de453a9afb128fd8d821c965dd_720w.jpg" alt="linux文件目录"></p>
<p>目录	   评论<br>&#x2F;	根目录，万物起源。<br>&#x2F;bin	包含系统启动和运行所必须的二进制程序。<br>&#x2F;boot	包含 Linux 内核，最初的 RMA 磁盘映像（系统启动时，由驱动程序所需），和<br>启动加载程序。<br>&#x2F;boot&#x2F;grub&#x2F;grub.conf or menu.lst， 被用来配置启动加载程序。<br>&#x2F;boot&#x2F;vmlinuz，Linux 内核。<br>&#x2F;dev	这是一个包含设备结点的特殊目录。“一切都是文件”，也使用于设备。 在这个目录里，内核维护着它支持的设备。<br>&#x2F;etc	这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是可读的文本文件。<br>虽然&#x2F;etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：<br>&#x2F;etc&#x2F;crontab， 定义自动运行的任务。<br>&#x2F;etc&#x2F;fstab，包含存储设备的列表，以及与他们相关的挂载点。<br>&#x2F;etc&#x2F;passwd，包含用户帐号列表。<br>&#x2F;home	在通常的配置环境下，系统会在&#x2F;home下，给每个用户分配一个目录。普通只能 在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。<br>&#x2F;lib	包含核心系统程序所需的库文件。这些文件与 Windows 中的动态链接库相似。<br>&#x2F;lost+found	每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。除非文件系统 真正的损坏了，那么这个目录会是个空目录。<br>&#x2F;media	在现在的 Linux 系统中，&#x2F;media 目录会包含可移除媒体设备的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些设备连接到计算机之后，会自动地挂载到这个目录结点下。<br>&#x2F;mnt	在早些的 Linux 系统中，&#x2F;mnt 目录包含可移除设备的挂载点。<br>&#x2F;opt	这个&#x2F;opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。<br>&#x2F;proc	这个&#x2F;proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。<br>反而，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。<br>&#x2F;root	root 帐户的家目录。<br>&#x2F;sbin	这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。<br>&#x2F;tmp	这个&#x2F;tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置，导致系统每次<br>重新启动时，都会清空这个目录。<br>&#x2F;usr	在 Linux 系统中，&#x2F;usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。<br>&#x2F;usr&#x2F;bin	&#x2F;usr&#x2F;bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。<br>&#x2F;usr&#x2F;lib	包含由&#x2F;usr&#x2F;bin 目录中的程序所用的共享库。<br>&#x2F;usr&#x2F;local	这个&#x2F;usr&#x2F;local 目录，是非系统发行版自带，却打算让系统使用的程序的安装目录。<br>通常，由源码编译的程序会安装在&#x2F;usr&#x2F;local&#x2F;bin 目录下。新安装的 Linux 系统中，会存在这个目录， 但却是空目录，直到系统管理员放些东西到它里面。<br>&#x2F;usr&#x2F;sbin	包含许多系统管理程序。<br>&#x2F;usr&#x2F;share	&#x2F;usr&#x2F;share 目录包含许多由&#x2F;usr&#x2F;bin<br>目录中的程序使用的共享数据。 其中包括像默认的配置文件，图标，桌面背景，音频文件等等。<br>&#x2F;usr&#x2F;share&#x2F;doc	大多数安装在系统中的软件包会包含一些文档。在&#x2F;usr&#x2F;share&#x2F;doc 目录下， 我们可以找到按照软件包分类的文档。<br>&#x2F;var	除了&#x2F;tmp 和&#x2F;home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。&#x2F;var 目录是可能需要改动的文件存储的地方。各种数据库，假脱机文件， 用户邮件等等，都驻扎在这里。<br>&#x2F;var&#x2F;log	这个&#x2F;var&#x2F;log 目录包含日志文件，各种系统活动的记录。这些文件非常重要，并且<br>应该时时监测它们。其中最重要的一个文件是&#x2F;var&#x2F;log&#x2F;messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。</p>
<p>开关机命令</p>
<p>1、shutdown –h now：立刻进行关机</p>
<p>2、shutdown –r now：现在重新启动计算机</p>
<p>3、reboot：现在重新启动计算机</p>
<p>4、su -：切换用户；passwd：修改用户密码</p>
<p>5、logout：用户注销</p>
<p>二、操作文件和目录</p>
<p>命令格式：命令 -选项 参数 （选项和参数可以为空）</p>
<p>0、pwd命令<br>Linux pwd（英文全拼：print work directory） 命令用于显示工作目录。</p>
<p>执行 pwd 指令可立刻得知您目前所在的工作目录的绝对路径名称。</p>
<p>pwd [–help][–version]<br>–help 在线帮助。</p>
<p>–version 显示版本信息。</p>
<p>1、展示目录列表命令ls（list）<br>ls 命令选项<br>-a，–all</p>
<p>#列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。</p>
<p>-d，–directory</p>
<p>#通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。</p>
<p>-F，–classify</p>
<p>#这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个’&#x2F;‘字符。</p>
<p>-h，–human-readable</p>
<p>#当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。</p>
<p>-l</p>
<p>#以长格式显示结果。</p>
<p>-r，–reverse</p>
<p>#以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。</p>
<p>-S</p>
<p>#命令输出结果按照文件大小来排序。</p>
<p>-t</p>
<p>#按照修改时间来排序。</p>
<p>2、mkdir - 创建目录 、 rmdir – 删除目录和</p>
<p>touch – 创建文件</p>
<p>mkdir dir1<br>创建一个名为”dir1”的目录</p>
<p>rmdir dir1<br>删除一个名为”dir1”的目录</p>
<p>touch dir1<br>创建一个名为”dir1”的文件</p>
<p>3、cp - 复制文件和目录<br>-a, –archive</p>
<p>#复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。</p>
<p>-i, –interactive</p>
<p>#在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。</p>
<p>-r, –recursive</p>
<p>#递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。</p>
<p>-u, –update</p>
<p>#当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</p>
<p>-v, –verbose</p>
<p>#显示翔实的命令操作信息</p>
<p>4、mv - 移动和重命名文件<br>mv 选项</p>
<p>-i –interactive</p>
<p>#在重写一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认重写文件内容。</p>
<p>-u –update</p>
<p>#当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。</p>
<p>-v –verbose 当操作 mv 命令时，显示翔实的操作信息。</p>
<p>mv 实例<br>mv file1 file2</p>
<p>#移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容重写。 如果 file2 不存在，则创建 file2。 每种情况下，file1 不再存在。</p>
<p>mv -i file1 file2</p>
<p>#除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。</p>
<p>mv file1 file2 dir1</p>
<p>#移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。</p>
<p>mv dir1 dir2</p>
<p>#如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。</p>
<p>5、rm - 删除文件和目录<br>rm 选项</p>
<p>-i, –interactive</p>
<p>#在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件</p>
<p>-r, –recursive</p>
<p>#递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</p>
<p>-f, –force</p>
<p>#忽视不存在的文件，不显示提示信息。这选项颠覆了“–interactive”选项。</p>
<p>-v, –verbose</p>
<p>#在执行 rm 命令时，显示翔实的操作信息。</p>
<p>6.文件打包或解压命令tar<br>tar -zcvf dir1.tar.gz</p>
<p>#打包成tar.gz格式压缩包</p>
<p>tar zxvf dir1.tar.gz</p>
<p>#解压tar.gz格式压缩包</p>
<p>tar -jcvf dir1.tar.bz2</p>
<p>#打包成tar.bz2格式压缩包</p>
<p>tar jxvf dir1.tar.bz2</p>
<p>#解压tar.bz2格式的压缩包</p>
<p>-c 建立新的备份文件。</p>
<p>-v 显示详细的tar处理的文件信息</p>
<p>-f 要操作的文件名</p>
<p>-r 递归处理，将指定目录下的所有文件和子目录一并处理</p>
<p>zip -q -r dir1.zip</p>
<p>#压缩成zip格式</p>
<p>unzip dir1.zip</p>
<p>#解压zip格式的压缩包</p>
<p>-q 不显示指令执行过程。</p>
<p>-r 递归处理，将指定目录下的所有文件和子目录一并处理。</p>
<p>7 、cat<br>cat命令用于连接文件并打印到标准输出设备上。</p>
<p>语法：</p>
<p>cat [-AbEnTv]</p>
<p>选项与参数：</p>
<p>-A 相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</p>
<p>-b 列出行号，仅针对非空白行做行号显示，空白行不标行号！</p>
<p>-E 将结尾的断行字节 $ 显示出来；</p>
<p>-n 列印出行号，连同空白行也会有行号，与 -b 的选项不同；</p>
<p>-T 将 [tab] 按键以 ^I 显示出来；</p>
<p>-v 列出一些看不出来的特殊字符</p>
<p>8、grep</p>
<p>Linux grep 命令用于查找文件里符合条件的字符串。 Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。</p>
<p>-c 只输出匹配行的计数。</p>
<p>-I 不区分大小写。</p>
<p>-h 查询多文件时不显示文件名。</p>
<p>-l 查询多文件时只输出包含匹配字符的文件名。</p>
<p>-n 显示匹配行及 行号。</p>
<p>-s 不显示不存在或无匹配文本的错误信息。</p>
<p>-v 显示不包含匹配文本的所有行。</p>
<p>–color&#x3D;auto 可以将找到的关键词部分加上颜色的显示。</p>
<p>三、系统常用操作命令</p>
<p>网络管理：ping、ifconfig<br>服务管理命令：<br>service:<br>格式：<br>service s_name start|stop|status|restart<br>linux系统所有自带服务名称：&#x2F;etc&#x2F;init.d&#x2F;</p>
<p>常用：<br>service iptables stop关闭防火墙服务</p>
<p>service network start 启动网卡</p>
<p>service network stop 关闭网卡</p>
<p>service network restart 重启网络</p>
<p>端口管理<br>nststat:查看端口开放情况<br>-a:表示列举所有的连接、服务器监听<br>-t:列出所有tcp协议的服务<br>-u:列出所有udp协议的服务<br>-n:使用端口号来显示<br>-l:列出所有的监听<br>-p:列出所有服务的进程id（pid）<br>常用：netstat -atunlp</p>
<p>四、软件包管理命令（apt）</p>
<p>不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营：Debian的”.deb”，和红帽的”.rpm”。也有一些重要的例外，比方说 Gentoo，Slackware，和Foresight，但大多数会使用这两个基本系统中的一个。</p>
<p>包管理系统	发行版 (部分列表)</p>
<p>apt和apt-get 命令适用于 deb 包管理式的 Linux 操作系统（Debian、Ubuntu等），主要用于自动从互联网软件仓库中搜索、下载、安装、升级、卸载软件或操作系统。</p>
<p>apt 命令 取代的命令 命令的功能</p>
<p>apt install | apt-get install | 安装软件包</p>
<p>apt remove | apt-get remove | 移除软件包</p>
<p>apt purge | apt-get purge | 除软件包及配置文件</p>
<p>apt update | apt-get update | 刷新存储库索引</p>
<p>apt upgrade | apt-get upgrade | 升级所有可升级的软件包</p>
<p>apt autoremove | apt-get autoremove | 自动删除不需要的包</p>
<p>apt full-upgrade | apt-get dist-upgrade | 在升级软件包时自动处理依赖关系</p>
<p>apt search | apt-cache search | 搜索应用程序</p>
<p>apt show | apt-cache show | 显示安装细节</p>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机和嵌入式系统的区别</title>
    <url>/archives/cc4d518f.html</url>
    <content><![CDATA[<h1 id="单片机和嵌入式系统的区别"><a href="#单片机和嵌入式系统的区别" class="headerlink" title="单片机和嵌入式系统的区别"></a>单片机和嵌入式系统的区别</h1><p>嵌入式和单片机并不是一对相对的概念，嵌入式系统包括硬件和软件部分，而单片机是单片微型计算机(Single Chip Microcomputer )的简称，即微控制单元(Microcontroller Unit；MCU) 。单片机可以是嵌入式系统的组成部分。我们可以理解为嵌入式系统是一个大类，单片机是其中一个重要的子类。</p>
<h1 id="什么是单片机？"><a href="#什么是单片机？" class="headerlink" title="什么是单片机？"></a>什么是单片机？</h1><p>单片机又称单片微控制器，它是将电子计算机的基本环节,如:中央处理器(又称中央处理器,主要由运算器,控制器组成),存储器,总线,输入输出接口等,采用集成电路技术集成在一片硅基片上.由于单片计算机体积很小(仅手指般大小),功能强(具有一个简单计算机的功能)。</p>
<h1 id="什么是嵌入式系统？"><a href="#什么是嵌入式系统？" class="headerlink" title="什么是嵌入式系统？"></a>什么是嵌入式系统？</h1><p>嵌入式系统是基于微处理器的计算机硬件系统，其软件设计用于执行专用功能，既可以作为独立系统，也可以作为大型系统的一部分。其核心是一个集成电路，旨在为实时操作执行计算。其软件内容只包括软件运行环境及其操作系统。硬件内容包括信号处理器、存储器、通信模块等在内的多方面的内容。</p>
<p>复杂性从单个微控制器到具有连接外围设备和网络的一套处理器；从无用户界面到复杂的图形用户界面。嵌入式系统的复杂性因设计任务而异。</p>
<p>嵌入式系统应用范围从数字手表和微波到混合动力汽车和航空电子设备。多达 98% 的制造的微处理器用于嵌入式系统。</p>
<p>嵌入式系统如何工作？</p>
<p>嵌入式系统由微控制器或数字信号处理器 (DSP)、专用集成电路 (ASIC)、现场可编程门阵列 (FPGA)、GPU 技术和门阵列管理。这些处理系统与专用于处理电气和&#x2F;或机械接口的组件集成在一起。</p>
<p>嵌入式系统编程指令，称为固件，存储在只读存储器或闪存芯片中，以有限的计算机硬件资源运行。嵌入式系统通过外围设备与外部世界连接，连接输入和输出设备。</p>
<p>嵌入式系统的基本结构</p>
<p><img src="https://pic3.zhimg.com/80/v2-510f561d07185b9ac8ce873cfa42d79e_720w.jpg" alt="嵌入式系统的基本结构"><br>嵌入式系统的基本结构包括以下组件：</p>
<p>传感器：传感器测量物理量并将其转换为电信号，然后可以由嵌入式系统工程师或任何电子仪器读取。传感器将测量的量存储到存储器中。</p>
<p>AD转换器：模数转换器将传感器发送的模拟信号转换为数字信号。<br>处理器和 ASIC：处理器评估数据以测量输出并将其存储到内存中。</p>
<p>DA 转换器：数模转换器将处理器提供的数字数据转换为模拟数据</p>
<p>执行器：执行器将 DA 转换器给出的输出与存储的实际输出进行比较，并存储批准的输出。</p>
<p>以常见的几种嵌入式开发板和单片机为例子</p>
<p>树莓派4B：<br><img src="https://pic3.zhimg.com/80/v2-e4113649f5c864c848977651efe67fde_720w.jpg" alt="树莓派4B"><br>Broadcom BCM2711, Quad core Cortex-A72 (ARM v8) 64-bit SoC @ 1.5GHz</p>
<p>Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi &#x2F; RPI) 是为学习计算机编程教育而设计)，只有信用卡大小的微型电脑，其系统基于Linux。</p>
<p>可以将树莓派理解为一台微型电脑，它与我们平时使用的电脑近乎相同。</p>
<p>Arduino：<br><img src="https://pic2.zhimg.com/80/v2-296df3f5f79f05cf00f9d1219ed160ed_720w.jpg" alt="Arduino"><br>AVR单片机、ARM芯片</p>
<p>Arduino是一款便捷灵活、方便上手的开源电子原型平台。</p>
<p>它构建于开放原始码simple I&#x2F;O介面版，并且具有使用类似Java、C语言的Processing&#x2F;Wiring开发环境。主要包含两个的部分：硬件部分是可以用来做电路连接的Arduino电路板；另外一个则是Arduino IDE，你的计算机中的程序开发环境。只要在IDE中编写程序代码，将程序上传到Arduino电路板后，程序会告诉Arduino电路板要做什么。</p>
<p>简单来说，arduino是对单片机的二次封装。</p>
<p>Stm32:<br><img src="https://pic1.zhimg.com/80/v2-66dc8e061c98669e0bf291326dbef7b4_720w.jpg" alt="stm32"><br>ARM Cortex-M内核单片机</p>
<p>stm32全称是意法半导体32位系列微控制器芯片。STM32系列专为要求高性能、低成本、低功耗的嵌入式应用设计的ARM Cortex®-M0，M0+，M3, M4和M7内核。</p>
<p>主流产品（STM32F0、STM32F1、STM32F3）、超低功耗产品（STM32L0、STM32L1、STM32L4、STM32L4+）、高性能产品（STM32F2、STM32F4、STM32F7、STM32H7）</p>
<p>51单片机：<br><img src="https://pic1.zhimg.com/80/v2-5f93514b9dbe056edf726476e000a680_720w.jpg" alt="51单片机"><br>51单片机是对兼容英特尔8051指令系统的单片机的统称</p>
<p>51单片机广泛应用于家用电器、汽车、工业测控、通信设备中。因为51单片机的指令系统、内部结构相对简单，所以国内许多高校用其进行单片机入门教学。</p>
<p>51单片机是Intel在1981年推出的由8031微控制器芯片改造升级的、使用CISC指令集的、冯诺依曼架构的、8位的8051微控制器。后Intel将8051微控制器的内核授权给其他芯片厂商,使得市面上广泛出现类似于8051的芯片,这种采用8051内核的芯片被简称为51。</p>
<p>从上述例子中我们能直观地看到这些开发板和单片机所使用处理器的不同，但是树莓派、Arduino、stm32和我们日常使用的手机均是使用arm架构的处理器，那么手机算单片机吗？</p>
<p>要回答这个问题，首先要简单介绍一下ARM处理器产品线。</p>
<p>ARM Cortex内核系列提供非常广泛的具有可扩展性的性能选项，设计人员有机会在多种选项中选择最适合自身应用的内核。Cortex系列组合大体上分为三种类别：</p>
<p>● Cortex-A—面向性能密集型系统的应用处理器内核</p>
<p>● Cortex-R—面向实时应用的高性能内核</p>
<p>● Cortex-M—面向各类嵌入式应用的微控制器内核</p>
<p><img src="https://pic2.zhimg.com/80/v2-f85640d3f7901185a13f066da1a9b191_720w.jpg" alt="处理器家族"><br>Cortex-A处理器为利用操作系统（例如Linux或者Android）的设备提供了一系列解决方案，这些设备被用于各类应用，从低成本手持设备到智能手机、平板电脑、机顶盒以及企业网络设备等。</p>
<p>Cortex-R实时处理器为要求可靠性、高可用性、容错功能、可维护性和实时响应的嵌入式系统提供高性能计算解决方案。在数以亿计的产品中得到验证的成熟技术提供极快的上市速度，并利用广泛的 ARM 生态系统、全球和本地语言以及全天候的支持服务，保证快速、低风险的产品开发。</p>
<p>Cortex-M系列基于ARMv7-M架构（用于Cortex-M3和Cortex-M4）构建，针对成本和功耗敏感的MCU和终端应用（如智能测量、人机接口设备、汽车和工业控制系统、大型家用电器、消费性产品和医疗器械）的混合信号设备进行过优化。</p>
<p>总结： Cortex-M 系列是MCU，也就是单片机，Cortex-R 系列处理器提供的性能比 Cortex-M 系列提供的性能高得多，而 Cortex-A 系列专用于具有复杂软件操作系统（需使用虚拟内存管理）的面向用户的应用。</p>
<p>综上所述，只有Cortex-A系列内核的芯片叫处理器。而上述的开发板和单片机只有Raspberry Pi以及我们日常使用的手机是Cortex-A系列内核的芯片。</p>
<p>单片机和嵌入式系统的结构</p>
<p>单片机： 软件 —— 硬件<br>嵌入式系统： 软件 ——操作系统——硬件</p>
<p>有无操作系统的区别</p>
<p>有操作系统可以实现多任务调度、文件系统、内存管理等复杂功能。</p>
<p>当系统中存在操作系统的时候，设备驱动变成了连接硬件和内核的桥梁。开发者调用统一的系统调用接口来访问各种设备，方便开发。提供操作方便、简单、提供友好的图形GUI和图形界面，追求易学易用。并且可以使用大量开源的软件，工具，库。</p>
<p>提供强大的网络功能，支持TCP&#x2F;IP协议及其他协议，提供TCP&#x2F;UDP&#x2F;IP&#x2F;PPP协议支持及统一的MAC访问层接口，为各种移动计算设备预留接口。可以实现远程控制。</p>
<p>拥有良好的软件移植性，嵌入式系统和具体应用有机地结合在一起，升级换代也是和具体产品同步进行，具有较长的生命周期。</p>
<p>而对于无操作系统的单片机而言，可以实现的功能相对单一。开发者必须要先了解这个硬件平台，才能进行软件编程，降低了开发效率且软件移植性差。</p>
<p>单片机的优势</p>
<p>从上文所述的种种优缺点来看，单片机对比嵌入式系统似乎一无是处，尽管嵌入式系统的性能强大且可实现功能众多，但嵌入式最大的劣势便是其高昂的价格。</p>
<p>单片机价格低廉，结构简单，使用方便，实现模块化，单片机可靠性高，可工作到10^6 ~10^7小时无故障，处理功能强，速度快。低电压，低功耗，控制功能强，环境适应能力强。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>日常使用Linux系统是什么体验？</title>
    <url>/archives/a1e2b7b3.html</url>
    <content><![CDATA[<p>趁着五一小假期，我尝试了去使用Linux作为日常使用的操作系统，这个过程中也是踩了不少的坑，所以想写一篇文章分享一下。</p>
<p>我个人使用过Kail、CentOS7、Ubuntu16.04、Windows Subsystem for Linux（WSL）作为开发环境，我个人更喜欢Debian Style (.deb)包管理系统，所以最终选择了使用Ubuntu18.04 LTS，打算在开发之余日常使用，满足听音乐，写文档，看看视频等需求。</p>
<h1 id="Ubuntu的优缺点："><a href="#Ubuntu的优缺点：" class="headerlink" title="Ubuntu的优缺点："></a>Ubuntu的优缺点：</h1><p><img src="https://pic3.zhimg.com/80/v2-c394ee5ef8e79d2c1ee12b659d08ec32_720w.jpg"></p>
<h1 id="安装Flash插件"><a href="#安装Flash插件" class="headerlink" title="安装Flash插件"></a>安装Flash插件</h1><p>使用Firefox 浏览器时，B站无法播放视频，提示需要下载Flash插件；<br><img src="https://pic1.zhimg.com/80/v2-1b63342350894d7b71807cdb3e57a2fc_720w.jpg"><br>点击页面跳转后却提示现在Adobe官网已经不再提供flash下载；</p>
<p>（由于 Adobe 在 2020 年 12 月 31 日之后不再支持 Flash Player，并且从 2021 年 1 月12 日开始阻止 Flash 内容在 Flash Player 中运行，因此 Adobe 强烈建议所有用户立即卸载 Flash Player 以帮助保护其系统。）<br><img src="https://pic1.zhimg.com/v2-a372fc674dc8c7eb9ef4e9318e474dc0_r.jpg"></p>
<p>解决办法是通过终端安装flash插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install flashplugin-installer</span><br></pre></td></tr></table></figure>
<p>或者</p>
<h2 id="安装ubuntu-restricted-extras；"><a href="#安装ubuntu-restricted-extras；" class="headerlink" title="安装ubuntu-restricted-extras；"></a>安装ubuntu-restricted-extras；</h2><p>ubuntu-restricted-extras 是一个包含各种基本软件，如 Flash 插件、unrar、gstreamer、mp4、Ubuntu 中的 Chromium 浏览器的编解码器等的软件包。</p>
<p>Ubuntu提供了一个软件包来安装所有基本的媒体编解码器：ubuntu-restricted-extras。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ubuntu-restricted-extras</span><br></pre></td></tr></table></figure>

<h1 id="安装Google-Chrome："><a href="#安装Google-Chrome：" class="headerlink" title="安装Google Chrome："></a>安装Google Chrome：</h1><p>直接使用Google浏览器也可以解决上述问题。</p>
<h2 id="1-下载谷歌浏览器"><a href="#1-下载谷歌浏览器" class="headerlink" title="1.下载谷歌浏览器"></a>1.下载谷歌浏览器</h2><p>下载最新的谷歌浏览器。带wget的deb包：</p>
<p>wget <a href="https://dl.google.com/linux/direct/google-chrome_stable_current_amd64.deb">https://dl.google.com/linux/direct/google-chrome_stable_current_amd64.deb</a></p>
<h2 id="2-安装谷歌浏览器"><a href="#2-安装谷歌浏览器" class="headerlink" title="2.安装谷歌浏览器"></a>2.安装谷歌浏览器</h2><p>在Ubuntu上安装软件包需要sudo权限。确保以具有sudo权限的用户身份运行以下命令。</p>
<p>安装谷歌浏览器。通过键入以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>

<p>安装deb包：<br>下载好deb包后，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./“安装包名”</span><br></pre></td></tr></table></figure>
<p>如上文所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>

<h1 id="输入法软件："><a href="#输入法软件：" class="headerlink" title="输入法软件："></a>输入法软件：</h1><h2 id="搜狗输入法："><a href="#搜狗输入法：" class="headerlink" title="搜狗输入法："></a>搜狗输入法：</h2><p>搜狗输入法Linux官网-首页</p>
<h3 id="1、添加中文语言支持"><a href="#1、添加中文语言支持" class="headerlink" title="1、添加中文语言支持"></a>1、添加中文语言支持</h3><p>打开 系统设置——区域和语言——管理已安装的语言——在“语言”tab下——点击“添加或删除语言”<br><img src="https://pic1.zhimg.com/80/v2-b248e5b921fa3cde2c018dbb74a09a68_720w.jpg"><br>弹出“已安装语言”窗口，勾选中文（简体），点击应用<br><img src="https://pic2.zhimg.com/80/v2-9784e564cfb3f4d55a89b0a9b459e7b5_720w.jpg"><br>回到“语言支持”窗口，在键盘输入法系统中，选择“fcitx”<br><img src="https://pic3.zhimg.com/80/v2-6ac417d2e68d2a9ab99b17f034fd3742_720w.jpg"></p>
<p>如果在键盘输入法系统中，没有“fcitx”选项时，建议先打开终端手动安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fcitx：sudo apt-get install fcitx</span><br></pre></td></tr></table></figure>
<p>等安装成功之后再执行上述步骤</p>
<p>点击“应用到整个系统”，关闭窗口，重启电脑</p>
<h3 id="2-通过命令行安装搜狗输入法"><a href="#2-通过命令行安装搜狗输入法" class="headerlink" title="2.通过命令行安装搜狗输入法"></a>2.通过命令行安装搜狗输入法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i sogoupinyin_版本号_amd64.deb</span><br></pre></td></tr></table></figure>
<p>如果安装过程中提示缺少相关依赖，则执行如下命令解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt -f install</span><br></pre></td></tr></table></figure>
<h3 id="3-注销计算机即可正常使用搜狗输入法。"><a href="#3-注销计算机即可正常使用搜狗输入法。" class="headerlink" title="3.注销计算机即可正常使用搜狗输入法。"></a>3.注销计算机即可正常使用搜狗输入法。</h3><h1 id="文档软件："><a href="#文档软件：" class="headerlink" title="文档软件："></a>文档软件：</h1><h2 id="Wps："><a href="#Wps：" class="headerlink" title="Wps："></a>Wps：</h2><p>WPS Office因酷似微软 Office 而广受欢迎。它的界面与微软 Office 几乎一样并且号称与微软 Office 更加兼容。<br><a href="https://www.wps.cn/product/wpslinux">https://www.wps.cn/product/wpslinux</a></p>
<h2 id="LibreOffice："><a href="#LibreOffice：" class="headerlink" title="LibreOffice："></a>LibreOffice：</h2><p>它是个组件完整的办公软件，包括文档编辑器、电子表格工具、演示软件、数学工具和作图工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libreoffice libreoffice-style-breeze</span><br></pre></td></tr></table></figure>
<h1 id="音乐软件："><a href="#音乐软件：" class="headerlink" title="音乐软件："></a>音乐软件：</h1><h2 id="网易云："><a href="#网易云：" class="headerlink" title="网易云："></a>网易云：</h2><p><a href="https://music.163.com/#/download">https://music.163.com/#/download</a></p>
<h1 id="聊天软件："><a href="#聊天软件：" class="headerlink" title="聊天软件："></a>聊天软件：</h1><h2 id="QQ："><a href="#QQ：" class="headerlink" title="QQ："></a>QQ：</h2><p><a href="https://im.qq.com/linuxqq/download.html">https://im.qq.com/linuxqq/download.html</a></p>
<h1 id="其他一些常用软件安装与使用："><a href="#其他一些常用软件安装与使用：" class="headerlink" title="其他一些常用软件安装与使用："></a>其他一些常用软件安装与使用：</h1><h2 id="VNC的使用及常见问题："><a href="#VNC的使用及常见问题：" class="headerlink" title="VNC的使用及常见问题："></a>VNC的使用及常见问题：</h2><h3 id="启动VNC"><a href="#启动VNC" class="headerlink" title="启动VNC"></a>启动VNC</h3><p>设置里打开共享<br><img src="https://pic3.zhimg.com/80/v2-bdad4403c861b8070edf35e06abc3f0a_720w.jpg"><br>设置密码并打开选项<br><img src="https://pic2.zhimg.com/80/v2-fe2ab52e283125190f7d46422d01d1a9_720w.jpg"><br>如果没有屏幕共享选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install dconf-editor</span><br></pre></td></tr></table></figure>
<p>或者，如果尚未安装 vino，请同时执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vino dconf-editor</span><br></pre></td></tr></table></figure>
<p>打开dconf-editor工具，终端输入 dconf-editor打开</p>
<p>打开之后，依次展开org-&gt;gnome-&gt;desktop-&gt;remote-access<br><img src="https://pic2.zhimg.com/80/v2-863b0116f3f2f976dda4a8c19f281259_720w.jpg"><br>打开相关选项即可。</p>
<h3 id="如果无法连接VNC服务端"><a href="#如果无法连接VNC服务端" class="headerlink" title="如果无法连接VNC服务端"></a>如果无法连接VNC服务端</h3><p>报错信息如下：</p>
<p>Unable to connect to VNC Server using your chosen security setting. Either upgrade VNC Server to a more recent version from RealVNC, or select a weaker level of encryption</p>
<p>解决办法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.Vino require-encryption <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="SSR："><a href="#SSR：" class="headerlink" title="SSR："></a>SSR：</h2><p>科学上网工具，下载地址：<br><a href="https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb">https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb</a></p>
<h2 id="GDebi："><a href="#GDebi：" class="headerlink" title="GDebi："></a>GDebi：</h2><p>Gedbi 是一款小巧的软件包管理器，你可以用它来安装 DEB 文件。它比软件中心更快，而且还能处理依赖问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdebi</span><br></pre></td></tr></table></figure>

<h2 id="Visual-Studio-Code："><a href="#Visual-Studio-Code：" class="headerlink" title="Visual Studio Code："></a>Visual Studio Code：</h2><p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
<h2 id="Steam："><a href="#Steam：" class="headerlink" title="Steam："></a>Steam：</h2><p><a href="https://store.steampowered.com/about/">https://store.steampowered.com/about/</a></p>
<h2 id="误删一些安装包导致无法打开系统设置："><a href="#误删一些安装包导致无法打开系统设置：" class="headerlink" title="误删一些安装包导致无法打开系统设置："></a>误删一些安装包导致无法打开系统设置：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnome-control-center</span><br></pre></td></tr></table></figure>

<h1 id="个人的一些感想："><a href="#个人的一些感想：" class="headerlink" title="个人的一些感想："></a>个人的一些感想：</h1><p>经过几天的使用，我发现Ubuntu在配置好环境后，日常体验还是相当不错的。</p>
<h2 id="但相对繁琐的软件安装步骤（学习成本较高）以及传统软件的缺乏（比如office全家桶）还是会让人放弃把Ubuntu或者其他Linux发行版作为日常使用的系统，即使-Linux-开发了相应的-Windows-软件替代品，使用体验还是不如Windows的。虽然-Linux-中网络是可靠的，但与-Windows-之间还是有差异的，不像-Windows-那样易于上手。并且Linux-的显卡支持也很麻烦，也缺乏-3A-游戏。尽管Steam-Deck的系统是基于Linux，但可以在Linux上流畅运行的游戏还是相对比较少的。"><a href="#但相对繁琐的软件安装步骤（学习成本较高）以及传统软件的缺乏（比如office全家桶）还是会让人放弃把Ubuntu或者其他Linux发行版作为日常使用的系统，即使-Linux-开发了相应的-Windows-软件替代品，使用体验还是不如Windows的。虽然-Linux-中网络是可靠的，但与-Windows-之间还是有差异的，不像-Windows-那样易于上手。并且Linux-的显卡支持也很麻烦，也缺乏-3A-游戏。尽管Steam-Deck的系统是基于Linux，但可以在Linux上流畅运行的游戏还是相对比较少的。" class="headerlink" title="但相对繁琐的软件安装步骤（学习成本较高）以及传统软件的缺乏（比如office全家桶）还是会让人放弃把Ubuntu或者其他Linux发行版作为日常使用的系统，即使 Linux 开发了相应的 Windows 软件替代品，使用体验还是不如Windows的。虽然 Linux 中网络是可靠的，但与 Windows 之间还是有差异的，不像 Windows 那样易于上手。并且Linux 的显卡支持也很麻烦，也缺乏 3A 游戏。尽管Steam Deck的系统是基于Linux，但可以在Linux上流畅运行的游戏还是相对比较少的。"></a>但相对繁琐的软件安装步骤（学习成本较高）以及传统软件的缺乏（比如office全家桶）还是会让人放弃把Ubuntu或者其他Linux发行版作为日常使用的系统，即使 Linux 开发了相应的 Windows 软件替代品，使用体验还是不如Windows的。虽然 Linux 中网络是可靠的，但与 Windows 之间还是有差异的，不像 Windows 那样易于上手。并且Linux 的显卡支持也很麻烦，也缺乏 3A 游戏。尽管Steam Deck的系统是基于Linux，但可以在Linux上流畅运行的游戏还是相对比较少的。</h2><p>（2022&#x2F;5&#x2F;12 补充回答）</p>
<p>因为之前的回答写得过于笼统，我决定补充一下回答。</p>
<p>首先讲讲为什么都2022年了，Ubuntu22.04都出了，为什么我还在使用Ubuntu18.04，原因也很简单，因为我使用Ubuntu的首要目标是搭建开发环境，而日常使用是其次的，使用18.04也只是因为环境搭建起来比较容易而已。这次没能用上Ubuntu22.04的新桌面GNOME 42，我觉得还是挺遗憾的。</p>
<p>再来讲讲我自己Linux的使用经历吧，我的Linux使用经验比较浅薄，我在19年年底才开始接触Linux，当时使用的是树莓派4B开发板，系统是Raspberry Pi OS，而我电脑上则是使用WSL，Ubuntu16.04版本。刚开始学习的时候，我算是完完全全的小白，只是知道Linux这么一个东西的存在，很难理解一个黑色的框框（终端）是操作系统。经过一段时间的学习后才算是明白了各种基本命令行的用法。后来在学校的机房里接触到CentOS8和RedHat，自己也出于好奇在虚拟机上跑Kali，学习关于网络的一些东西，但是也没有想过日常去使用这些Linux发行版。其实树莓派系统是有桌面的，但我平时都是用vscode+ssh去开发，所以也没什么接触Linux桌面的机会。可以说在这个假期前，我对Linux桌面的接触接近于0。</p>
<p>经过这次假期短暂的使用后，接下来再讲讲我的小结，Linux确实可以应付所有的“日常使用”场景的，但在我看来更适合于开发。Linux的使用是有门槛的，即使拥有了桌面，离开了命令行界面（CLI），Linux上的很多操作都寸步难行。虽然我觉得CLI用起来很帅，很高效，但对于以日常使用为目的而不是开发的小白用户来说，CLI便是使用Linux的难点之一。反观Windows出色的图形用户界面（GUI），操作方便直观且学习成本低，在日常使用中普通用户一般也不需要使用到cmd和powershell。我举个不太恰当的例子，Linux发行版就像毛坯房需要自己去动手装修，桌面也只是给了一个基本的框架，自由度高，可以各种自定义各种魔改，比较适合动手能力强爱折腾的用户，而Windows就像已经装修好的样本房，即买即住，适合图省心的用户。（那么如果有一个上手简便，不需要CLI即可操作并且桌面功能完善的发行版一定会受到用户的欢迎吧）</p>
<p>在软件方面，适配Linux的软件也是远少于Windows，如经典的office全家桶，各类工程软件以及常用软件。Linux下的游戏还是比较匮乏的，数量上远少于Windows。显卡驱动也是Linux的使用难点之一，而最近英伟达已经开源 Linux GPU 内核驱动了，未来可期。希望软件和游戏厂商以后能给Linux做更多的适配吧。</p>
<p>还有一个问题就是国内特殊的网络环境以及中文互联网资料比较贫瘠，我寻找到的很多资料都已经是过时无效的了，使用好相关论坛可以节省掉不少的时间。</p>
<p>相比Windows下泛滥的各式流氓软件，Linux则不需要担心这个问题，并且更为干净安全可靠，也没有像微软那样三天两头就更新的各式补丁。</p>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（一）</title>
    <url>/archives/5dd58e55.html</url>
    <content><![CDATA[<h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><p>计算机网络是“以相互共享资源的方式互联起来的自治计算机系统的集合”。<br>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><p>计算机网络按照其覆盖的地理范围进行分类，可以很好地反映不同类型网络的技术特征。按照覆盖的地理范围划分，计算机网络可以分为以下5类。</p>
<h3 id="广域网（Wide-Area-Network，WAN）"><a href="#广域网（Wide-Area-Network，WAN）" class="headerlink" title="广域网（Wide Area Network，WAN）"></a>广域网（Wide Area Network，WAN）</h3><h3 id="城域网-Metropolitan-Area-Network，MAN"><a href="#城域网-Metropolitan-Area-Network，MAN" class="headerlink" title="城域网(Metropolitan Area Network，MAN)"></a>城域网(Metropolitan Area Network，MAN)</h3><h3 id="局域网（Local-Area-Network-，LAN）"><a href="#局域网（Local-Area-Network-，LAN）" class="headerlink" title="局域网（Local Area Network ，LAN）"></a>局域网（Local Area Network ，LAN）</h3><h3 id="个人区域网（Personal-Area-Network，PAN）"><a href="#个人区域网（Personal-Area-Network，PAN）" class="headerlink" title="个人区域网（Personal Area Network，PAN）"></a>个人区域网（Personal Area Network，PAN）</h3><h3 id="人体区域网（Body-Area-Network，BAN）"><a href="#人体区域网（Body-Area-Network，BAN）" class="headerlink" title="人体区域网（Body Area Network，BAN）"></a>人体区域网（Body Area Network，BAN）</h3><h3 id="网络体系结构和网络协议"><a href="#网络体系结构和网络协议" class="headerlink" title="网络体系结构和网络协议"></a>网络体系结构和网络协议</h3><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议类似于人类协议，除了交换报文和采取动作的实体是某些设备（可以是计算机、智能手机、平板电脑、路由器或其他具有网络能力的设备）的硬件或软件组件。在因 特网中，涉及两个或多个远程通信实体的所有活动都受协议的制约。例如，在两台物理上 连接的计算机中，硬件实现的协议控制了在两块网络接口卡间的“线上”的比特流；在端 系统中，拥塞控制协议控制了在发送方和接收方之间传输的分组发送的速率；路由器中的协议决定了分组从源到目的地的路径。<br>协议（protocol）定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接收一条报文或其他事件所采取的动作。<br>因特网（更一般地说是计算机网络）广泛地使用了协议。不同的协议用于完成不同的通信任务。<br>    层次（layer）结构事处理计算机网络问题最基本的方法。对于一些难以处理的复杂问题，通常是采用若干个容易处理的、小一些的问题，“化整为零，分而治之”的方法去解决。<br>接口是同一主机内相邻层之间交换信息的连接点。<br>对于结构复杂的网络协议体系来说，最好的组织方是层次结构模型。计算机网络引入了一个重要的概念——网络体系结构（network architecture）。</p>
<h2 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h2><p>1974年，IBM公司提出世界第一个网络体系结构——系统网络体系结构（SNA）。1974年，国际标准化组织（ISO）发布了著名的ISO&#x2F;IEC7498标准，定义了网络互联的7层框架，即开放系统互连（Open System Interconnect，OSI）参考模型。<br>开放系统互连 (OSI) 模型描述了计算机系统用于通过网络进行通信的七个层次。OSI参考模型包括以下七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。<br><img src="https://pic3.zhimg.com/80/v2-82a2e89aa4a4218d23a8aedba5b77ad2_720w.jpg" alt="OSI七层模型"></p>
<p>现代互联网不是基于 OSI，而是基于更简单的 TCP&#x2F;IP 模型。然而，OSI 7 层模型仍然被广泛使用，因为它有助于可视化和传达网络的运行方式，并有助于隔离和解决网络问题。<br>我们将“自上而下”地描述 OSI 层，从直接为最终用户服务的应用程序层，一直到物理层。<br><img src="https://pic1.zhimg.com/80/v2-112f5d6be901f464ec832561b4f98f48_720w.jpg" alt="主机、路由器和链路层交换机，每个包含了不同的层，反映了它们的功能差异"></p>
<h3 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h3><p>应用层由最终用户软件使用，例如 Web 浏览器和电子邮件客户端。它提供允许软件发送和接收信息并向用户呈现有意义的数据的协议。应用层协议的一些示例是超文本传输协议(HTTP)、文件传输协议 (FTP)、邮局协议 (POP)、简单邮件传输协议 (SMTP) 和域名系统 (DNS)。</p>
<h3 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6.表示层"></a>6.表示层</h3><p>表示层为应用层准备数据。它定义了两个设备应如何编码、加密和压缩数据，以便在另一端正确接收数据。表示层获取应用层传输的任何数据，并准备好通过会话层传输。</p>
<h3 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5.会话层"></a>5.会话层</h3><p>会话层在设备之间创建通信通道，称为会话。它负责打开会话，确保它们在传输数据时保持打开和功能，并在通信结束时关闭它们。会话层还可以在数据传输期间设置检查点——如果会话中断，设备可以从上一个检查点恢复数据传输。</p>
<h3 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h3><p>传输层获取会话层中传输的数据，并在发送端将其分解为“段”。它负责在接收端重新组装段，将其转换回会话层可以使用的数据。传输层进行流量控制，以与接收设备的连接速度相匹配的速率发送数据，以及错误控制，检查数据是否接收错误，如果没有，则重新请求。</p>
<h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h3><p>网络层有两个主要功能。一种是将分段分解为网络数据包，然后在接收端重新组装数据包。另一种是通过发现跨物理网络的最佳路径来路由数据包。网络层使用网络地址（通常是 Internet 协议地址）将数据包路由到目标节点。</p>
<h3 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h3><p>数据链路层在网络上两个物理连接的节点之间建立和终止连接。它将数据包分解成帧并将它们从源发送到目标。该层由两部分组成——逻辑链路控制 (LLC)，它识别网络协议、执行错误检查和同步帧，以及媒体访问控制 (MAC)，它使用 MAC 地址连接设备并定义传输和接收数据的权限。</p>
<h3 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h3><p>物理层负责网络节点之间的物理有线或无线连接。它定义了连接器、连接设备的电缆或无线技术，并负责传输原始数据，这只是一系列 0 和 1，同时负责比特率控制。<br>OSI模型的优点<br>OSI 模型帮助计算机网络的用户和运营商：<br>•	确定构建网络所需的硬件和软件。<br>•	了解并传达组件通过网络进行通信的过程。<br>•	通过确定导致问题的网络层并将工作重点放在该层来执行故障排除。<br>OSI 模型帮助网络设备制造商和网络软件供应商：<br>•	创建可以与任何其他供应商的产品进行通信的设备和软件，从而实现开放的互操作性<br>•	定义他们的产品应该使用的网络部分。<br>•	与用户沟通他们的产品在哪些网络层运行——例如，仅在应用层，或跨堆栈。</p>
<h2 id="OSI-与-TCP-x2F-IP-模型"><a href="#OSI-与-TCP-x2F-IP-模型" class="headerlink" title="OSI 与 TCP&#x2F;IP 模型"></a>OSI 与 TCP&#x2F;IP 模型</h2><p><img src="https://pic3.zhimg.com/80/v2-c39270e61b82808e07c29a4f143199d2_720w.jpg" alt="TCP/IP与OSI对应关系"></p>
<p>传输控制协议&#x2F;互联网协议(TCP&#x2F;IP) 比 OSI 模型更早，由美国国防部 (DoD) 创建。模型之间的一个关键区别是 TCP&#x2F;IP 更简单，将几个 OSI 层合并为一个：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1127aaa36d2eff825865f1020568d18f_720w.jpg" alt="TCP/IP与OSI对应关系"></p>
<p>OSI 第 5、6、7 层在 TCP&#x2F;IP 中合并为一个应用层<br>OSI 第 1 层、第 2 层在 TCP&#x2F;IP 中合并为一个网络访问层 - 但是 TCP&#x2F;IP 不负责排序和确认功能，将这些留给底层传输层。<br>其他重要区别：<br>TCP&#x2F;IP 是一种功能模型，旨在解决特定的通信问题，它基于特定的标准协议。OSI 是一个通用的、独立于协议的模型，旨在描述所有形式的网络通信。<br>在 TCP&#x2F;IP 中，大多数应用程序使用所有层，而在 OSI 中简单应用程序不使用所有七层。只有第 1、2 和 3 层是必需的才能启用任何数据通信。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Raidenxe/PicWarehouse/img/%E9%A3%8E%E6%99%AF008.png" alt="TCP/IP与OSI对应关系"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派系统烧录教程</title>
    <url>/archives/6a0755b3.html</url>
    <content><![CDATA[<p>树莓派的系统烧录大体上可分为使用</p>
<p>官方的烧录工具Raspberry Pi Imager烧录和使用第三方烧录工具烧录。</p>
<p>官方的烧录工具胜在操作简单，方便快捷，所以这里使用Raspberry Pi Imager进行演示。</p>
<p>具体步骤如下：</p>
<p>首先准备好tf卡和读卡器</p>
<p>然后进入官网下载 <a href="https://link.zhihu.com/?target=https://www.raspberrypi.com/software/">Raspberry Pi Imager</a></p>
<p><img src="https://pic4.zhimg.com/80/v2-8a14d7c95dec632584c034d0dc88b28b_720w.jpg" alt="选择download for windows"></p>
<p>安装Raspberry Pi Imager<br><img src="https://pic1.zhimg.com/80/v2-c4e4c22348914ce68edf31226bb6f340_720w.jpg" alt="点击Install"><br><img src="https://pic2.zhimg.com/80/v2-84775579e1f5e109e7cfb486f4aab445_720w.jpg" alt="Finish"></p>
<p>打开Raspberry Pi Imager<br><img src="https://pic4.zhimg.com/80/v2-4eae49e0a08f4a124f1a8a74ebc7970b_720w.jpg" alt="点击CHOOSE OS选项"></p>
<p>这里我们可以看到有很多系统可供选择，可以自行选择适合的系统，</p>
<p>这里我们选择带有树莓派桌面的第一个系统为例<br><img src="https://pic2.zhimg.com/80/v2-112d84b8ae1fa0b9dcd92a6325576ae9_720w.jpg" alt="点击Raspberry PI OS(32-bit)"></p>
<p>选择对应的存储设备<br><img src="https://pic1.zhimg.com/80/v2-a5d82eae153723595f4c1944cf3f797c_720w.jpg" alt="点击CHOOSE STORAGE选项"><br><img src="https://pic3.zhimg.com/80/v2-f6cf4fe01e8b59da659a6e37c9db9aae_720w.jpg" alt="注意所选盘符是否为目标tf卡"></p>
<p>烧录程序<br><img src="https://pic4.zhimg.com/80/v2-16125a207574f1440b2e52738d1a7c47_720w.jpg" alt="点击WRITE"><br><img src="https://pic1.zhimg.com/80/v2-71484bd203bca4874eeb82a93026a360_720w.jpg" alt="点击yes"></p>
<p>接下来耐心等待即可<br><img src="https://pic4.zhimg.com/80/v2-7d813e812b9816d4339a448576daa9bf_720w.jpg" alt="等进度条达100％即完成树莓派系统的烧录"></p>
<p>如果出现报错，可以尝试重新烧录系统。</p>
]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（七）网络分析之tcpdump抓包</title>
    <url>/archives/f792503a.html</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>tcpdump</strong>是一个运行在命令行下的数据包分析器。它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP&#x2F;IP和其他数据包。tcpdump 是一个在BSD许可证下发布的自由软件。</p>
<p>tcpdump 适用于大多数的类Unix系统 操作系统：包括Linux、Solaris、BSD、Mac OS X、HP-UX和AIX 等等。在这些系统中，tcpdump 需要使用libpcap这个捕捉数据的库。其在Windows下的版本称为WinDump；它需要WinPcap驱动，相当于在Linux平台下的libpcap。</p>
<h1 id="tcpdump的作用"><a href="#tcpdump的作用" class="headerlink" title="tcpdump的作用"></a>tcpdump的作用</h1><p>TCPDump可以将网络中传送的数据包完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<p>Linux作为网络服务器，特别是作为路由器和网关时，数据的采集和分析是不可少的。TcpDump是Linux中强大的网络数据采集分析工具之一。</p>
<p>也可以使用 tcpdump 的实现特定目的，例如在路由器和网关之间拦截并显示其他用户或计算机通信。通过 tcpdump 分析非加密的流量，如Telnet或HTTP的数据包，查看登录的用户名、密码、网址、正在浏览的网站内容，或任何其他信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。</p>
<p>有很多用户喜欢使用柏克莱数据包过滤器来限制 tcpdump 产生的数据包数量，这样BPF会只把“感兴趣”的数据包到上层软件，可以避免从操作系统内核向用户态复制其他数据包，降低抓包的CPU的负担以及所需的缓冲区空间，从而减少丢包率。</p>
<p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。</p>
<p>作为互联网上经典的的系统管理员必备工具，tcpdump以其强大的功能，灵活的截取策略，成为每个高级的系统管理员分析网络，排查问题等所必备的工具之一。</p>
<h1 id="权限要求"><a href="#权限要求" class="headerlink" title="权限要求"></a>权限要求</h1><p>一些类Unix操作系统，用户有必须拥有超级用户权限方可使用 tcpdump，因为在这些系统需要使用超级用户权限将网络界面设置为混杂模式。然而，可以通过使用 -Z 选项在完成嗅探之后站即下降到一个特定的非特权用户的权限。在某一些类Unix操作系统，数据包嗅探机制可以配置为允许非特权用户可以使用它，如果做到这一点，就不需要超级用户权限。</p>
<h1 id="tcpdump命令格式"><a href="#tcpdump命令格式" class="headerlink" title="tcpdump命令格式"></a>tcpdump命令格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump [-adeflnNOpqStvx][-c&lt;数据包数目&gt;][-<span class="built_in">dd</span>][-ddd][-F&lt;表达文件&gt;][-i&lt;网络界面&gt;][-r&lt;数据包文件&gt;][-s&lt;数据包大小&gt;][-tt][-T&lt;数据包类型&gt;][-vv][-w&lt;数据包文件&gt;][输出数据栏位]</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-6e1cf98d900276da039df3060792e94b_720w.jpg"></p>
<h1 id="tcpdump输出格式"><a href="#tcpdump输出格式" class="headerlink" title="tcpdump输出格式"></a>tcpdump输出格式</h1><p>基本上tcpdump的总的输出格式为：系统时间 来源主机.端口 &gt; 目标主机.端口 数据包参数</p>
<h1 id="抓包选项："><a href="#抓包选项：" class="headerlink" title="抓包选项："></a>抓包选项：</h1><p>-c：指定要抓取的包数量。</p>
<p>-i interface：指定tcpdump需要监听的接口。默认会抓取第一个网络接口</p>
<p>-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。</p>
<p>-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。</p>
<p>-P：指定要抓取的包是流入还是流出的包。可以给定的值为”in”、”out”和”inout”，默认为”inout”。</p>
<p>-s：&lt;数据包大小&gt; 设置每个数据包的大小。</p>
<p>-S：用绝对而非相对数值列出TCP关联数。</p>
<p>-t：在每列倾倒资料上不显示时间戳记。</p>
<p>-tt：在每列倾倒资料上显示未经格式化的时间戳记。</p>
<h1 id="输出选项："><a href="#输出选项：" class="headerlink" title="输出选项："></a>输出选项：</h1><p>-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。</p>
<p>-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。</p>
<p>-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。</p>
<p>-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。</p>
<p>-v：当分析和打印的时候，产生详细的输出。</p>
<p>-vv：产生比-v更详细的输出。</p>
<p>-vvv：产生比-vv更详细的输出。</p>
<h1 id="参考实例"><a href="#参考实例" class="headerlink" title="参考实例"></a>参考实例</h1><p>我这里使用Kali Linux系统作为演示且使用root权限。</p>
<h2 id="1-默认启动"><a href="#1-默认启动" class="headerlink" title="1.默认启动"></a>1.默认启动</h2><p>默认情况下，直接启动tcpdump将监视第一个网络接口(非lo口)上所有流通的数据包。这样抓取的结果会非常多，滚动非常快。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-e8c1e081f2039f2b1f292467ae9f394d_720w.jpg"></p>
<p>2.监视指定网络接口的数据包<br>在生产环境中，与默认启动类似同样有大量报文产生，所以可能瞬间导致服务器资源耗尽，慎用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-53faa27c423f5dcbf043ec421bf3209f_720w.jpg"></p>
<p>3.监视指定主机的数据包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump host kali-2021</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-b767bf42718d6dcb4f7ed3176c89625c_720w.png"></p>
<p>4.抓取80端口的HTTP报文</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i any port 80</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-74c549b71f6efbe446f154282304c8dc_720w.jpg"></p>
<p>5.显示指定数量包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -c 20</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-b07ea1b0ffae2a584897959667317418_720w.jpg"></p>
<p>6.精简显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -c 10 -q</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-bad6150e0a001c934dee99bfd630bda1_720w.jpg"></p>
<p>7.过滤主机<br>抓取所有经过eth0，目的或源地址是192.168.1.1的网络数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 host 192.168.1.1</span><br></pre></td></tr></table></figure>
<p>指定源地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 src host 192.168.1.1 </span><br></pre></td></tr></table></figure>
<p>指定目的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 dst host 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>8.过滤端口<br>抓取所有经过eth0，目的或源端口是25的网络数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 port 25 </span><br></pre></td></tr></table></figure>
<p>指定源端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 src port 25 </span><br></pre></td></tr></table></figure>
<p>指定目的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 dst port 25</span><br></pre></td></tr></table></figure>

<p>9.网络过滤<br>抓取所有经过eth0，网段为192.168的网络数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 net 192.168</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-52611f844a206c4da8a6b9eb60b66b53_720w.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 src net 192.168</span><br><span class="line">tcpdump -i eth0 dst net 192.168</span><br></pre></td></tr></table></figure>

<p>10.协议过滤</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 arp </span><br><span class="line">tcpdump -i eth1 ip </span><br><span class="line">tcpdump -i eth1 tcp </span><br><span class="line">tcpdump -i eth1 udp </span><br><span class="line">tcpdump -i eth1 icmp</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络安全</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（三）Socket基本函数详解，C++ Socket入门实战</title>
    <url>/archives/7a099087.html</url>
    <content><![CDATA[<p>在上文中，简单介绍了一下什么是socket以及简单举例Socket如何实现客户端和服务端</p>
<p>本文将会为详细地讲述Socket的一些基本函数以及如何简单使用socket搭建一个聊天室。</p>
<h2 id="Socket数据结构"><a href="#Socket数据结构" class="headerlink" title="Socket数据结构"></a>Socket数据结构</h2><p><img src="https://pic4.zhimg.com/80/v2-0b01629d0a64c309ca2fb28d027df23b_720w.jpg" alt="Socket数据结构"><br><img src="https://pic1.zhimg.com/80/v2-f3ee7745b97d088ee4a918f23761581c_720w.jpg" alt="Socket数据结构"></p>
<h2 id="Linux系统下的头文件"><a href="#Linux系统下的头文件" class="headerlink" title="Linux系统下的头文件"></a>Linux系统下的头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Windows系统下的头文件"><a href="#Windows系统下的头文件" class="headerlink" title="Windows系统下的头文件"></a>Windows系统下的头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="服务端与客户端通信过程"><a href="#服务端与客户端通信过程" class="headerlink" title="服务端与客户端通信过程"></a>服务端与客户端通信过程</h2><p><img src="https://pic3.zhimg.com/80/v2-d770bce3a03c14eb48e3aa2d24ad1dc6_720w.jpg" alt="通信过程"></p>
<h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><h3 id="套接字类型的创建"><a href="#套接字类型的创建" class="headerlink" title="套接字类型的创建"></a>套接字类型的创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> __domain, <span class="type">int</span> __type, <span class="type">int</span> __protocol)</span></span></span><br></pre></td></tr></table></figure>
<p>参数介绍</p>
<p>第一个参数domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL。</p>
<p>地址族及含义</p>
<p>AF_INET</p>
<p>IPv4网络协议中采用的地址族</p>
<p>AF_INET6</p>
<p>IPv6网络协议中采用的地址族</p>
<p>AF_LOCAL</p>
<p>本地通信中采用的UNIX协议的地址族（用的少）</p>
<p>第二个参数type：指定socket类型。常用的有SOCKET_RAW，SOCK_STREAM和SOCK_DGRAM。</p>
<p>套接字类型及含义</p>
<p>SOCKET_RAW</p>
<p>原始套接字(SOCKET_RAW)允许对较低层次的协议直接访问，比如IP、ICMP协议。</p>
<p>SOCK_STREAM是数据流，一般为TCP&#x2F;IP协议的编程。</p>
<p>SOCK_DGRAM是数据报，一般为UDP协议的网络编程；</p>
<p>第三个参数protocol：指定协议。最终采用的协议。常见的协议有IPPROTO_TCP、IPPTOTO_UDP。</p>
<p>如果第二个参数选择了SOCK_STREAM，那么采用的协议就只能是IPPROTO_TCP；</p>
<p>如果第二个参数选择的是SOCK_DGRAM，则采用的协议就只能是IPPTOTO_UDP。</p>
<p>当protocol为0时，会自动选择type类型对应的默认协议。</p>
<h3 id="向套接字分配网络类型"><a href="#向套接字分配网络类型" class="headerlink" title="向套接字分配网络类型"></a>向套接字分配网络类型</h3><p>bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<p>int bind(int __fd, const sockaddr *__addr, socklen_t __len)<br>第一个参数socket文件描述符__fd：即套接字创建时返回的对象，</p>
<p>第二个参数addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。包含通信所需要的相关信息，其结构体具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span></span><br><span class="line">  &#123;</span><br><span class="line"> <span class="type">sa_family_t</span> sin_family; <span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line"> <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">/* Address data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>在具体传参的时候，会用该结构体的变体sockaddr_in形式去初始化相关字段，该结构体具体形式如下，结构体sockaddr中的sa_data就保存着地址信息需要的IP地址和端口号，对应着结构体sockaddr_in的sin_port和sin_addr字段。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line"> <span class="type">sa_family_t</span> sin_family;     <span class="comment">//前面介绍的地址族</span></span><br><span class="line"> <span class="type">uint16_t</span> sin_port;          <span class="comment">//16位的TCP/UDP端口号</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;    <span class="comment">//32位的IP地址</span></span><br><span class="line"> <span class="type">char</span> sin_zero[<span class="number">8</span>];           <span class="comment">//不使用</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="进入等待连接请求状态"><a href="#进入等待连接请求状态" class="headerlink" title="进入等待连接请求状态"></a>进入等待连接请求状态</h3><p>给套接字分配了所需的信息后，服务端就可以调用listen()函数对来自客户端的连接请求进行监听（客户端此时要调用connect()函数进行连接）</p>
<p>Listen函数的第一个参数即为要监听的socket套接字，第二个参数为相应socket可以排队的最大连接个数。</p>
<p>Connect函数的第一个参数即为客户端的socket套接字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。</p>
<h3 id="处理服务端的连接请求"><a href="#处理服务端的连接请求" class="headerlink" title="处理服务端的连接请求"></a>处理服务端的连接请求</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> __fd, sockaddr *__restrict__ __addr, <span class="type">socklen_t</span> *__restrict__ __addr_len)</span></span></span><br></pre></td></tr></table></figure>
<p>函数成功执行时返回socket文件描述符，失败时返回-1。</p>
<p>accept函数的第一个参数为服务器的socket描述字，</p>
<p>第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，</p>
<p>第三个参数为协议地址的长度。</p>
<p>accept函数返回的是已连接的socket套接字。</p>
<h4 id="在TCP-x2F-IP协议中-TCP协议提供可靠的连接服务-采用三次握手建立一个连接。"><a href="#在TCP-x2F-IP协议中-TCP协议提供可靠的连接服务-采用三次握手建立一个连接。" class="headerlink" title="在TCP&#x2F;IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接。"></a>在TCP&#x2F;IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接。</h4><p><img src="https://pic2.zhimg.com/80/v2-9dcd196f5ff3307d2e8fe6f08b54c641_720w.jpg" alt="三次握手"></p>
<p>第一次握手：建立连接时,客户端发送syn包(syn&#x3D;j)到服务器,并进入SYN_SEND状态,等待服务器确认；</p>
<p>SYN：同步序列编号(Synchronize Sequence Numbers)</p>
<p>第二次握手：服务器收到syn包,必须确认客户的SYN（ack&#x3D;j+1）,同时自己也发送一个SYN包（syn&#x3D;k）,即SYN+ACK包,此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack&#x3D;k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手。</p>
<p>完成三次握手,客户端与服务器开始传送数据。</p>
<h4 id="四次挥手结束连接"><a href="#四次挥手结束连接" class="headerlink" title="四次挥手结束连接"></a>四次挥手结束连接</h4><p><img src="https://pic3.zhimg.com/80/v2-1a8261c7ffa27588f3d06c741311cd86_720w.jpg" alt="四次挥手"></p>
<p>由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>简单来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。</p>
<h3 id="write-x2F-send发送信息"><a href="#write-x2F-send发送信息" class="headerlink" title="write&#x2F;send发送信息"></a>write&#x2F;send发送信息</h3><p>Linux下的发送函数为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">const</span> <span class="type">void</span> *__buf, <span class="type">size_t</span> __n)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>而在Windows下的发送函数为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flag)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>第四个参数是传输数据时可指定的信息，一般设置为0。</p>
<h3 id="read-x2F-recv接受信息"><a href="#read-x2F-recv接受信息" class="headerlink" title="read&#x2F;recv接受信息"></a>read&#x2F;recv接受信息</h3><p>linux下的接收函数为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> __fd, <span class="type">void</span> *__buf, <span class="type">size_t</span> __n, <span class="type">int</span> __flags)</span></span></span><br></pre></td></tr></table></figure>
<p>而在windows下的接收函数为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flag)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数指定接收端套接字描述符；</p>
<p>第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</p>
<p>第三个参数指明buf的长度；</p>
<p>第四个参数一般置0</p>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> __fd)</span></span></span><br></pre></td></tr></table></figure>
<p>退出连接，此时要注意的是：调用close()函数即表示向对方发送了EOF结束标志信息。</p>
<h3 id="C-x2F-C-代码实战"><a href="#C-x2F-C-代码实战" class="headerlink" title="C&#x2F;C++代码实战"></a>C&#x2F;C++代码实战</h3><p>以下代码仅供参考，且在Linux环境下运行，需要先运行服务端再运行客户端，仅能实现客户端给服务端发送信息的简单功能。</p>
<h4 id="client-cpp"><a href="#client-cpp" class="headerlink" title="client.cpp"></a>client.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYPORT 7000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> sockCli = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">///定义sockaddr_in</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"> <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"> servaddr.sin_family = AF_INET;</span><br><span class="line"> servaddr.sin_port = <span class="built_in">htons</span>(MYPORT);                 <span class="comment">//服务器端口</span></span><br><span class="line"> servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">//服务器ip，inet_addr用于IPv4的IP转换（十进制转换为二进制）</span></span><br><span class="line">                                                       <span class="comment">// 127.0.0.1是本地预留地址</span></span><br><span class="line">                                                       <span class="comment">//连接服务器，成功返回0，错误返回-1</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">connect</span>(sockCli, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="type">char</span> sendbuf[BUFFER_SIZE];</span><br><span class="line"> <span class="type">char</span> recvbuf[BUFFER_SIZE];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span> (<span class="built_in">fgets</span>(sendbuf, <span class="built_in">sizeof</span>(sendbuf), stdin) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;                                               <span class="comment">/*每次读取一行，读取的数据保存在buf指向的字符数组中，成功，则返回第一个参数buf；*/</span></span><br><span class="line"> <span class="built_in">send</span>(sockCli, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>); <span class="comment">///发送</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(sendbuf, <span class="string">&quot;exit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// recv(sockCli, recvbuf, sizeof(recvbuf), 0); ///接收</span></span><br><span class="line">        <span class="comment">// fputs(recvbuf, stdout);</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(sendbuf)); <span class="comment">//接受或者发送完毕后把数组中的数据全部清空（置0）</span></span><br><span class="line"> <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="built_in">close</span>(sockCli);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Server-cpp"><a href="#Server-cpp" class="headerlink" title="Server.cpp"></a>Server.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 7000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE 20 <span class="comment">//连接请求队列</span></span></span><br><span class="line"><span class="type">int</span> conn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> sockSer = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//若成功则返回一个sockfd（套接字描述符）</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_sockaddr;            <span class="comment">//一般是储存地址和端口的。用于信息的显示及存储使用</span></span><br><span class="line">                                                   <span class="comment">/*设置 sockaddr_in 结构体中相关参数*/</span></span><br><span class="line"> server_sockaddr.sin_family = AF_INET;</span><br><span class="line"> server_sockaddr.sin_port = <span class="built_in">htons</span>(PORT); <span class="comment">//将一个无符号短整型数值转换为网络字节序，即大端模式(big-endian) </span></span><br><span class="line">                                            <span class="comment">// printf(&quot;%d\n&quot;,INADDR_ANY);</span></span><br><span class="line">    <span class="comment">// INADDR_ANY就是指定地址为0.0.0.0的地址，这个地址事实上表示不确定地址，或“所有地址”、“任意地址”。</span></span><br><span class="line">    <span class="comment">//一般来说，在各个系统中均定义成为0值。</span></span><br><span class="line"> server_sockaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//将主机的无符号长整形数转换成网络字节顺序。</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">bind</span>(sockSer, (<span class="keyword">struct</span> sockaddr *)&amp;server_sockaddr, <span class="built_in">sizeof</span>(server_sockaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">listen</span>(sockSer, QUEUE) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line"> <span class="type">socklen_t</span> length = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="comment">///成功返回非负描述字，出错返回-1</span></span><br><span class="line"> conn = <span class="built_in">accept</span>(sockSer, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;length);</span><br><span class="line">    <span class="comment">//如果accpet成功，那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接。</span></span><br><span class="line">    <span class="comment">// accpet之后就会用新的套接字conn</span></span><br><span class="line"> <span class="keyword">if</span> (conn &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"> <span class="type">int</span> len = <span class="built_in">recv</span>(conn, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>); <span class="comment">//从TCP连接的另一端接收数据。</span></span><br><span class="line">        <span class="comment">/*该函数的第一个参数指定接收端套接字描述符；</span></span><br><span class="line"><span class="comment"> 第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</span></span><br><span class="line"><span class="comment"> 第三个参数指明buf的长度；</span></span><br><span class="line"><span class="comment"> 第四个参数一般置0*/</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;exit\n&quot;</span>) == <span class="number">0</span>) <span class="comment">//如果没有收到TCP另一端发来的数据则跳出循环不输出</span></span><br><span class="line">        &#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer); <span class="comment">//如果有收到数据则输出数据</span></span><br><span class="line">        <span class="comment">//必须要有返回数据， 这样才算一个完整的请求</span></span><br><span class="line"> <span class="built_in">send</span>(conn, buffer, len, <span class="number">0</span>); <span class="comment">//向TCP连接的另一端发送数据。</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="built_in">close</span>(conn); <span class="comment">//因为accpet函数连接成功后还会生成一个新的套接字描述符，结束后也需要关闭</span></span><br><span class="line"> <span class="built_in">close</span>(sockSer);   <span class="comment">//关闭socket套接字描述符</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
        <tag>Socket</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（二）什么是Socket？它跟TCP/IP的关系是什么？</title>
    <url>/archives/8cdebc07.html</url>
    <content><![CDATA[<h2 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h2><p>Socket允许在相同或不同机器上的两个不同进程之间进行通信。更准确地说，这是一种使用标准 Unix 文件描述符与其他计算机通信的方式。</p>
<p>在 Unix 中，每个 I&#x2F;O 操作都是通过写入或读取文件描述符来完成的。文件描述符只是与打开的文件相关联的整数，它可以是网络连接、文本文件、终端或其他东西。</p>
<p>对于程序员来说，套接字的外观和行为很像低级文件描述符。这是因为诸如 read() 和 write() 之类的命令对套接字的工作方式与它们对文件和管道的工作方式相同。</p>
<p>套接字最初是在 2.1BSD 中引入的，随后在 4.2BSD 中被改进为当前的形式。现在，大多数最新的 UNIX 系统版本都提供了套接字功能。<br><img src="https://pic1.zhimg.com/80/v2-33d5adb9c5bdefa9977a7f64970834a0_720w.jpg" alt="Socket与各种网络协议的关系"><br>如图所示，Socket是为了给应用程序一个更加统一、简洁的API接口而将底层各种协议栈封装起来形成形成的一层接口函数。</p>
<p>简单举例Socket如何实现客户端和服务端<br><img src="https://pic3.zhimg.com/80/v2-50a90c813007b71ef251e00f5cf7692e_720w.jpg" alt="客户端和服务端信息交互"><br>构建客户端和服务器的方式有所不同，但都涉及到Socket的基本构造。这两个进程都建立了自己的套接字。</p>
<h2 id="如何构建客户端"><a href="#如何构建客户端" class="headerlink" title="如何构建客户端"></a>如何构建客户端</h2><p>在客户端建立Socket的步骤如下 ：</p>
<p>1.使用socket()系统调用创建一个套接字。</p>
<p>2.使用connect()系统调用将套接字连接到服务器的地址。</p>
<p>3.发送和接收数据。有很多方式可以实现这一点，最简单的方法就是使用read()和write()系统调用。</p>
<h2 id="如何构建服务端"><a href="#如何构建服务端" class="headerlink" title="如何构建服务端"></a>如何构建服务端</h2><p>在服务器端建立套接字的步骤如下 ：</p>
<p>1.使用socket()系统调用创建一个套接字。</p>
<p>2.使用bind()系统调用将套接字绑定到一个地址。对于 Internet 上的服务器套接字，地址由主机上的端口号组成。</p>
<p>3.通过listen()系统调用监听连接。</p>
<p>4.通过accept()系统调用接受连接。此调用通常会阻止连接，直到客户端与服务器连接。</p>
<p>5.使用read()和write()系统调用发送和接收数据。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（八）IPv4协议基本原理详解</title>
    <url>/archives/ae61cc04.html</url>
    <content><![CDATA[<p>IPv4协议是计算机网络中的重点，既是互联网的核心，也是使用最广泛的网际协议版本。而我们日常接触到最多的网络协议同样是IPv4。本文旨在较为全面地介绍IPv4协议的一些 基本概念以及 基本原理，帮助自己以及读者梳理IPv4协议的一些知识点。</p>
<h1 id="IPv4引言"><a href="#IPv4引言" class="headerlink" title="IPv4引言"></a>IPv4引言</h1><p><strong>网际协议版本4</strong>（英语：Internet Protocol version 4，缩写：IPv4，又称互联网通信协议第四版）是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。其后继版本为IPv6，直到2011年，IANA IPv4位址完全用尽时，IPv6仍处在部署的初期。</p>
<p>IPv4在IETF于1981年9月发布的 RFC 791 中被描述，此RFC替换了于1980年1月发布的 RFC 760。</p>
<p>IPv4是一种<strong>无连接</strong>的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。这些方面是由上层的传输协议（如传输控制协议）处理的。</p>
<h1 id="IPv4协议发展和演变过程"><a href="#IPv4协议发展和演变过程" class="headerlink" title="IPv4协议发展和演变过程"></a>IPv4协议发展和演变过程</h1><p><img src="https://pic1.zhimg.com/80/v2-c30348bdecae5edcfb5b6818f19d79d4_720w.jpg"></p>
<h1 id="IP协议的主要特点"><a href="#IP协议的主要特点" class="headerlink" title="IP协议的主要特点"></a>IP协议的主要特点</h1><p><strong>1.IP协议是一种无连接、不可靠的分组传送服务的协议</strong></p>
<p><strong>2.IP协议是点-点的网络层通信协议</strong></p>
<p><strong>3.IP协议屏蔽了互联的网络在数据链路层、物理层协议与实现技术上的差异</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-c060953586d50a1758c3c77f8498e839_720w.jpg"></p>
<h1 id="IPv4地址的特点"><a href="#IPv4地址的特点" class="headerlink" title="IPv4地址的特点"></a>IPv4地址的特点</h1><p>1.IP 地址是一种非等级的地址结构， IP 地址不能反映任何有关主机位置的地理信息，只能通过网络号码字段判断出主机属于哪个网络。</p>
<p>2.当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号码 Net-id 是不同的，这种主机称为多地址主机（Multihomed Host）。主机上的每个接口都对应着一个 IP 地址，因此多接口主机会有多个 IP 地址。</p>
<p>3.在 IP 地址中，所有分配到网络号码 Net-id 的网络都是平等的。</p>
<p>4.IPv4地址空间少于<strong>40亿</strong>个，实际可以使用的更少。</p>
<p>5.IPv4不区分网络终端主机和终端设备，每台电脑都可以作为主机和路由器。路由协议管理路由表记录，常用的路由协议有路由信息协议、开放最短路径协议、边界网关协议等。</p>
<p>6.IPv4独立于特定的网络硬件，可以运行在局域网、广域网、互联网中。网络地址分配方案唯一，设备有唯一的地址。</p>
<p>7.IPv4缺乏对安全性的支持，无法实现网络实名制。网络中节点配置很复杂，不能满足用户“即插即用”的需求口。</p>
<h1 id="IPv4分组格式"><a href="#IPv4分组格式" class="headerlink" title="IPv4分组格式"></a>IPv4分组格式</h1><h2 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h2><p><img src="https://pic2.zhimg.com/80/v2-d4bd9b60633868608572e72818fbf255_720w.jpg"><br>网络层分组被称为数据报。我们以概述IPv4数据报的语法和语义开始对IP的学习。你也许认为没有什么比一个分组的比特的语法和语义更加枯燥无味的了。无论如何,数据报在因特网中起着重要作用,每个网络行业的学生和专业人员都需要理解它、吸收它并掌握它。IPv4数据报格式如图所示。</p>
<p>IPv4分组由两个部分组成：分组头和数据。分组头也被称为“首部”，其长度是可变的。人们习惯使用4字节为基本单元表示分组头字段。图中分组头每行宽度是4字节，前5行是每个分组头中必须有的字段，第6行开始的是选项字段，因此IPv4分组头的基本长度是20字节。如果加上最长的40字节的选项，则IP分组头最大长度为60字节。</p>
<h2 id="IPv4分组头格式"><a href="#IPv4分组头格式" class="headerlink" title="IPv4分组头格式"></a>IPv4分组头格式</h2><p>IPv4报文的首部包含14个字段，其中13个是必须的，第14个是可选的（红色标出），并命名为：“选项”字段。首部中的字段均以大端序包装，在以下的图表和讨论中，最高有效位（Most Significant bit）被标记为0。<br><img src="https://pic2.zhimg.com/80/v2-35cff58ddb93c07a71b05826b04a1791_720w.jpg"></p>
<h3 id="（1）版本（Version）"><a href="#（1）版本（Version）" class="headerlink" title="（1）版本（Version）"></a>（1）版本（Version）</h3><p>版本字段占4bit，表示所使用的网络层IP协议的版本号。通信双方使用的版本必须一致。字段的值是4，表示IPv4，字段的值是6，表示IPv6。</p>
<h3 id="（2）首部长度（Internet-Header-Length，-IHL）"><a href="#（2）首部长度（Internet-Header-Length，-IHL）" class="headerlink" title="（2）首部长度（Internet Header Length， IHL）"></a>（2）首部长度（Internet Header Length， IHL）</h3><p>首部长度占4bit，首部长度说明首部有多少32位字（4字节）。因为一个IPv4 数据报可包含一些可变数量的选项，这个字段也用来确定数据的偏移量。这个字段的最小值为5（二进制0101），相当于5*4&#x3D;20字节（RFC 791），最大十进制值是15。</p>
<h3 id="（3）区分服务（Differentiated-Services，DS）"><a href="#（3）区分服务（Differentiated-Services，DS）" class="headerlink" title="（3）区分服务（Differentiated Services，DS）"></a>（3）区分服务（Differentiated Services，DS）</h3><p>在首部长度字段后，最早的RFV0791规定了一个长度为8bit的服务类型（ToS），ToS字段用了4位：D（延迟）、T（吞吐量）、R（可靠性）、C（成本）。但是ToS字段在路由器中并没有很好地利用起来。</p>
<p>1998年RFC2474、RFC3168、RFC3260重新定义了这个长度为8bit的字段，前6bit定义为服务类型字段，后2bit为显式拥塞通告。只有在使用区分服务时，这个字段才起作用，在一般的情况下都不使用这个字段。例如需要实时数据流的技术会应用这个字段，一个例子是VoIP。</p>
<h4 id="（3-1）服务类型-TOS）包含在IPv4首部中，以便使不同类型的IP数据报（例如，一些特别要求低时延、高吞吐量或可靠性的数据报）能相互区别开来。例如，将实时数据报（如用于IP电话应用-与非实时流量（如FTP-区分开也许是有用的。提供特定等级的服务是一个由网络管理员对路由器确定和配置的策略问题。"><a href="#（3-1）服务类型-TOS）包含在IPv4首部中，以便使不同类型的IP数据报（例如，一些特别要求低时延、高吞吐量或可靠性的数据报）能相互区别开来。例如，将实时数据报（如用于IP电话应用-与非实时流量（如FTP-区分开也许是有用的。提供特定等级的服务是一个由网络管理员对路由器确定和配置的策略问题。" class="headerlink" title="（3.1）服务类型(TOS）包含在IPv4首部中，以便使不同类型的IP数据报（例如，一些特别要求低时延、高吞吐量或可靠性的数据报）能相互区别开来。例如，将实时数据报（如用于IP电话应用)与非实时流量（如FTP)区分开也许是有用的。提供特定等级的服务是一个由网络管理员对路由器确定和配置的策略问题。"></a>（3.1）服务类型(TOS）包含在IPv4首部中，以便使不同类型的IP数据报（例如，一些特别要求低时延、高吞吐量或可靠性的数据报）能相互区别开来。例如，将实时数据报（如用于IP电话应用)与非实时流量（如FTP)区分开也许是有用的。提供特定等级的服务是一个由网络管理员对路由器确定和配置的策略问题。</h4><h4 id="（3-2-）显式拥塞通告（-Explicit-Congestion-Notification，ECN）在RFC-3168中定义，允许在不丢弃报文的同时通知对方网络拥塞的发生。ECN是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。"><a href="#（3-2-）显式拥塞通告（-Explicit-Congestion-Notification，ECN）在RFC-3168中定义，允许在不丢弃报文的同时通知对方网络拥塞的发生。ECN是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。" class="headerlink" title="（3.2 ）显式拥塞通告（ Explicit Congestion Notification，ECN）在RFC 3168中定义，允许在不丢弃报文的同时通知对方网络拥塞的发生。ECN是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。"></a>（3.2 ）显式拥塞通告（ Explicit Congestion Notification，ECN）在RFC 3168中定义，允许在不丢弃报文的同时通知对方网络拥塞的发生。ECN是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。</h4><h3 id="（4）全长（Total-Length）"><a href="#（4）全长（Total-Length）" class="headerlink" title="（4）全长（Total Length）"></a>（4）全长（Total Length）</h3><p>这是IP数据报的总长度（首部加上数据)，以字节计。因为该字段长为16比特，所以IP数据报的理论最大长度为65535字节。然而，数据报很少有超过1500字节的，该长度使得IP数据报能容纳最大长度以太网帧的载荷字段。当下层的数据链路协议的最大传输单元（MTU）字段的值小于IP报文长度时，报文就必须被分片。</p>
<p>标识符（Identification）、标志（Flags）、片偏移（Fragment Offset）。这三个字段与所谓IP分片有关。有趣的是，新版本的IP(即 IPv6）不允许在路由器上对分组分片。</p>
<h3 id="（5）存活时间（Time-To-Live，TTL）"><a href="#（5）存活时间（Time-To-Live，TTL）" class="headerlink" title="（5）存活时间（Time To Live，TTL）"></a>（5）存活时间（Time To Live，TTL）</h3><p>这个8位字段避免报文在互联网中永远存在（例如陷入路由环路）。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减1，当此字段等于0时，报文不再向下一跳传送并被丢弃，最大值是255。常规地，一份ICMP报文被发回报文发送端说明其发送的报文已被丢弃。这也是traceroute的核心原理。</p>
<h3 id="（6）协议-（Protocol）"><a href="#（6）协议-（Protocol）" class="headerlink" title="（6）协议 （Protocol）"></a>（6）协议 （Protocol）</h3><p>占8bit，这个字段定义了该报文数据区使用的协议。IANA维护着一份协议列表（最初由RFC 790定义），详细参见IP协议号列表。</p>
<h3 id="（7）首部检验和-（Header-Checksum）"><a href="#（7）首部检验和-（Header-Checksum）" class="headerlink" title="（7）首部检验和 （Header Checksum）"></a>（7）首部检验和 （Header Checksum）</h3><p>这个16位检验和字段只对首部查错，不包括数据部分。在每一跳，路由器都要重新计算出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。重新计算的必要性是因为每一跳的一些首部字段（如TTL、Flag、Offset等）都有可能发生变化，不检查数据部分是为了减少工作量。数据区的错误留待上层协议处理——用户数据报协议（UDP）和传输控制协议（TCP）都有检验和字段。此处的检验计算方法不使用CRC。RFC 1071</p>
<h3 id="（8）地址（Address）"><a href="#（8）地址（Address）" class="headerlink" title="（8）地址（Address）"></a>（8）地址（Address）</h3><p>地址字段包括源地址与目的地址。</p>
<p>源地址（Source address）</p>
<p>一个IPv4地址由四个字节共32位构成，此字段的值是将每个字节转为二进制并拼在一起所得到的32位值。例如，10.9.8.7是00001010000010010000100000000111。但请注意，因为NAT的存在，这个地址并不总是报文的真实发送端，因此发往此地址的报文会被送往NAT设备，并由它被翻译为真实的地址。</p>
<p>目的地址（Destination address）</p>
<p>与源地址格式相同，但指出报文的接收端。</p>
<h3 id="（9）选项（Options）"><a href="#（9）选项（Options）" class="headerlink" title="（9）选项（Options）"></a>（9）选项（Options）</h3><p>选项字段允许IP首部被扩展。首部选项意味着很少使用，因此决定对每个数据报首部不包括选项字段中的信息，这样能够节约开销。然而，少量选项的存在的确使问题复杂了，因为数据报首部长度可变，故不能预先确定数据字段从何处开始。而且还因为有些数据报要求处理选项，而有些数据报则不要求，故导致一台路由器处理一个IP数据报所需的时间变化可能很大。这些考虑对于高性能路由器和主机上的IP处理来说特别重要。由于这样或那样的原因，在IPv6首部中已去掉了IP选项。</p>
<h2 id="标准分类IP地址"><a href="#标准分类IP地址" class="headerlink" title="标准分类IP地址"></a>标准分类IP地址</h2><h1 id="网络地址的基本概念"><a href="#网络地址的基本概念" class="headerlink" title="网络地址的基本概念"></a>网络地址的基本概念</h1><p>理解网络地址需要注意以下问题</p>
<h2 id="（1）名字、地址与路径"><a href="#（1）名字、地址与路径" class="headerlink" title="（1）名字、地址与路径"></a>（1）名字、地址与路径</h2><p>RFC791指出了<strong>名字（name）</strong>、<strong>地址（address）</strong>与<strong>路径（route）</strong>概念的区别。名字说明是谁，地址说明在哪，路径说明如何找到。</p>
<h2 id="（2）MAC地址与IP地址"><a href="#（2）MAC地址与IP地址" class="headerlink" title="（2）MAC地址与IP地址"></a>（2）MAC地址与IP地址</h2><p><strong>MAC地址</strong>（英语：Media Access Control Address），直译为媒体访问控制地址，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的地址。在OSI模型中，第三层网络层负责IP地址，第二层数据链接层则负责MAC地址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</p>
<p>互联网络是由多个网络互联而成的。连接到每个局域网的每台计算机都有一块网卡，也就是说每台计算机都有一个MAC地址。这个MAC地址被称为“物理地址”。IP地址是网络层的地址，主要用于路由器的寻址，因此IP地址采用层次结构。相对于数据链路层的固定和不变的物理地址，网络层是由网关人员分配和通过软件设置来设置的，因此人们也把它称为“逻辑地址”。</p>
<h2 id="（3）IP地址和网络接口"><a href="#（3）IP地址和网络接口" class="headerlink" title="（3）IP地址和网络接口"></a>（3）IP地址和网络接口</h2><p>在讨论IP编址之前，我们需要简述一下主机与路由器连入网络的方法。一台主机通常只有一条链路连接到网络;当主机中的IP想发送一个数据报时，它就在该链路上发送。主机与物理链路之间的边界叫作接口（ interface)。现在考虑一台路由器及其接口。因为路由器的任务是从链路上接收数据报并从某些其他链路转发出去，路由器必须拥有两条或更多条链路与它连接。路由器与它的任意一条链路之间的边界也叫作接口。一台路由器因此有多个接口，每个接口有其链路。因为每台主机与路由器都能发送和接收IP数据报，IP要求每台主机和路由器接口拥有自己的IP地址。因此，从技术上讲，一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</p>
<h2 id="（4）IP地址的分配方法"><a href="#（4）IP地址的分配方法" class="headerlink" title="（4）IP地址的分配方法"></a>（4）IP地址的分配方法</h2><p>1.为每一个网络接口分配一个IP地址。</p>
<p>2.为多归属主机的每一个网络接口分配相应的IP地址。</p>
<p>3.可以为一个网络接口分配多个IP地址。</p>
<h1 id="IPv4地址分类"><a href="#IPv4地址分类" class="headerlink" title="IPv4地址分类"></a>IPv4地址分类</h1><p>每个IP地址长度为32比特（等价为4字节)，因此总共有23个（或大约40亿个)可能的IP地址。这些地址通常按所谓点分十进制记法（ dotted-decimal notation）书写，即地址中的每个字节用它的十进制形式书写，各字节间以句点隔开。<br><img src="https://pic1.zhimg.com/80/v2-e369ec618faa638b1d7e97c153e51d24_720w.jpg"><br><strong>A级地址：</strong> 以0为首的8位网络地址 + 24位本地地址 ，常用于主机大于2^16个主机的大型网络中。</p>
<p><strong>B级地址：</strong>以10为首的16为网络地址 +16位本地地址，常用于2^8-2^16个主机的中型网络中。</p>
<p><strong>C级地址：</strong>以110为首的24位网络地址 + 8位本地地址，常用于2^8以下的小型网络中。</p>
<p><strong>D 级地址：</strong>以1110为首的32位多播地址，即同时会向网络中多个工作站进行发送的一个地址。</p>
<p><strong>E级地址：</strong>1 1 1 1 0 ，暂时保留，用于某些实验和将来使用。</p>
<p><strong>说明：D类与E类IPv4地址不区分网络地址与主机地址。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-4b7359d86ab034dccf91554d22d5e93c_720w.jpg"><br>最初，一个IP地址被分成两部分：网络标识符在地址的高位字节中，主机标识符在剩下的部分中。</p>
<p>为了克服这个限制，在随后出现的分类网络中，地址的高位字节被重定义为网络的类(Class)。这个系统定义了五个类别：A、B、C、D和E。A、B和C类有不同的网络类别长度，剩余的部分被用来识别网络内的主机，这就意味着每个网络类别有着不同的给主机编址的能力。D类被用于多播地址，E类被留作将来使用。</p>
<p><img src="https://pic2.zhimg.com/80/v2-698d5faca4f523f0678334bf38790fcd_720w.jpg"></p>
<h1 id="IPv4地址格式"><a href="#IPv4地址格式" class="headerlink" title="IPv4地址格式"></a>IPv4地址格式</h1><p>IPv4地址可被写作任何表示一个32位整数值的形式，但为了方便人类阅读和分析[1]，它通常被写作点分十进制的形式，即四个字节被分开用十进制写出，中间用点分隔。</p>
<p>下表展示了几种不同的格式：<br><img src="https://pic2.zhimg.com/80/v2-1d43b2a0de83f825e00d5125ccf718c1_720w.jpg"></p>
<p>此外，在点分格式中，每个字节都可用任意的进制表达。</p>
<p>如，192.0x00.0002.235是一种合法（但不常用）的表示。点分格式也支持零省略的写法，例如127.1.1等同于127.1.0.1。</p>
<h1 id="划分子网的三级地址结构"><a href="#划分子网的三级地址结构" class="headerlink" title="划分子网的三级地址结构"></a>划分子网的三级地址结构</h1><h2 id="1-子网的概念"><a href="#1-子网的概念" class="headerlink" title="1.子网的概念"></a>1.子网的概念</h2><p>标准分类的IP地址存在着两个主要问题：IP地址的有效利用率与路由器的工作效率。为了解决这个问题，人们提出子网(subnet)的概念。</p>
<p>IP地址是以网络号和主机号来表示网络上的主机的，只有在一个网络号下的计算机之间才能“直接”互通，不同网络号的计算机要通过网关（Gateway）才能互通。但这样的划分在某些情况下显得并不十分灵活。为此IP网络还允许划分成更小的网络，称为子网（Subnet）。</p>
<p>说得更具体一些就是为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫作一个子网。</p>
<p>如果我们将该过程用于图4-20中的互联系统上，会得到6个岛或子网。<br><img src="https://pic4.zhimg.com/80/v2-9d258201c500387e5f7467e97ffe5383_720w.jpg"></p>
<h2 id="2-划分子网的地址结构"><a href="#2-划分子网的地址结构" class="headerlink" title="2.划分子网的地址结构"></a>2.划分子网的地址结构</h2><p>IP地址根据网络号和主机号的数量而分为A、B、C三类：IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是4个字节。例如一个采用二进制形式的IP地址是“00001010000000000000000000000001”，这么长的地址，人们处理起来也太费劲了。为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。于是，上面的IP地址可以表示为“10.0.0.1”。IP地址的这种表示法叫做“点分十进制表示法”，显然比1和0容易记忆得多。</p>
<p>（1）三级层次的IP是：net ID-subnet ID host ID，增加了一级网号subnet ID。</p>
<p>（2）同一个子网中所有的主机必须使用相同的网络号与子网号（net ID-subnet ID）。</p>
<p>（3）子网的概念可以用于A、B、C三类IP地址。</p>
<p>（4）子网之间的距离必须很近。分配子网是一个组织和单位内部的事，它既不要向ICANN申请，也不需要改变任何外部路由器的数据库。</p>
<h2 id="3-子网掩码的概念"><a href="#3-子网掩码的概念" class="headerlink" title="3.子网掩码的概念"></a>3.子网掩码的概念</h2><p>当包括子网号的三层结构的IP地址出现后，一个很现实的问题是：如何从IP地址中提取出子网号。为了解决这个问题，人们提出子网掩码（subnet mask）或掩码（mask）的概念。子网掩码有时又称为子网屏蔽码。</p>
<p>子网掩码：把基于每类的IP地址等级进一步分成更小的网络，每个子网由路由器界定并分配一个新的子网网络地址,子网地址是借用基于每类的网络地址的主机部分创建的。划分子网后，通过使用掩码，把子网隐藏起来，使得从外部看网络没有变化，这就是子网掩码。子网掩码用于辨别IP地址中哪部分为网络地址，哪部分为主机地址。</p>
<p>即 IP地址 &amp; 子网掩码 &#x3D; 网络地址。</p>
<p>掩码的概念同样适用于没有进行子网划分的A类、B类或C类地址。</p>
<h2 id="4-可变长度子网掩码（Variable-Length-Subnet-Mask）技术"><a href="#4-可变长度子网掩码（Variable-Length-Subnet-Mask）技术" class="headerlink" title="4.可变长度子网掩码（Variable Length Subnet Mask）技术"></a>4.可变长度子网掩码（Variable Length Subnet Mask）技术</h2><p>在某种情况下，需要在子网划分时考虑不同的子网号长度。RFC1009文档对变长子网的划分做出了说明。</p>
<p>**VLSM(可变长子网掩码) **是为了有效的使用无类别域间路由（CIDR）和路由汇聚(route summary)来控制路由表的大小，它是网络管理员常用的IP寻址技术，VLSM就是其中的常用方式，可以对子网进行层次化编址，以便最有效的利用现有的地址空间。</p>
<h1 id="无类别域间路由"><a href="#无类别域间路由" class="headerlink" title="无类别域间路由"></a>无类别域间路由</h1><h2 id="1-无类别域间路由的基本概念"><a href="#1-无类别域间路由的基本概念" class="headerlink" title="1.无类别域间路由的基本概念"></a>1.无类别域间路由的基本概念</h2><p>在可变长度子网掩码基础上，人们提出了<strong>无类别域间路由（Classless Inter-Domain Routing、CIDR）</strong>的概念。CIDR是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。</p>
<p>在RFC 950（1985）中有关于可变长子网掩码的说明。CIDR包括：</p>
<p>指定任意长度的前缀的可变长子网掩码技术。遵从CIDR规则的地址有一个后缀说明前缀的位数，例如：192.168.0.0&#x2F;16。这使得对日益缺乏的IPv4地址的使用更加有效。<br>将多个连续的前缀聚合成超网，以及，在互联网中，只要有可能，就显示为一个聚合的网络，因此在总体上可以减少路由表的表项数目。聚合使得互联网的路由表不用分为多级，并通过VLSM逆转“划分子网”的过程。<br>根据机构的实际需要和短期预期需要而不是分类网络中所限定的过大或过小的地址块来管理IP地址的分配的过程。<br>因为在IPv6中也使用了IPv4的用后缀指示前缀长度的CIDR，所以IPv4中的分类在IPv6中已不再使用。</p>
<p>因特网的地址分配策略被称为无类别域间路由选择。CIDR将子网寻址的概念一般化了。当使用子网寻址时，32比特的IP地址被划分为两部分，并且也具有点分十进制数形式a. b. c. d&#x2F; x，其中x指示了地址的第一部分中的比特数。</p>
<p>形式为a. b.c. d&#x2F;x的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的前缀（ prefix)(或网络前缀)。一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。在这种情况下，该组织内部的设备的IP地址将共享共同的前缀。这就是说，当该组织外部的一台路由器转发一个数据报，且该数据报的目的地址位于该组织的内部时，仅需要考虑该地址的前面x比特。这相当大地减少了在这些路由器中转发表的长度，</p>
<p>因为形式为a.b.c. d&#x2F;x的单一表项足以将数据报转发到该组织内的任何目的地。</p>
<h2 id="2-层次编址与路由聚合"><a href="#2-层次编址与路由聚合" class="headerlink" title="2.层次编址与路由聚合"></a>2.层次编址与路由聚合</h2><p><img src="https://pic1.zhimg.com/80/v2-856fe2567f32bc9bb85025281109f5bc_720w.jpg"><br>这是一个ISP将8个组织连接到因特网的例子，它也很好地说明了仔细分配CIDR化的地址有利于路由选择的道理。如图4-21所示，假设该ISP（我们称之为Fly- By-Night-ISP)向外界通告，它应该发送所有地址的前20比特与200.23.16.0&#x2F;20相符的数据报。外界的其他部分不需要知道在地址块200.23.16.0&#x2F;20内实际上还存在8个其他组织，其中每个组织有自己的子网。这种使用单个网络前缀通告多个网络的能力通常称为地址聚合( address aggregation )，也称为路由聚合( route aggregation）或路由摘要( route summarization)。</p>
<p>网络地址转换<br>NAT (Network Address Translation)又称为网络地址转换，用于实现私有网络和公有网络之间的互访。</p>
<h3 id="1-网络地址转换技术的背景"><a href="#1-网络地址转换技术的背景" class="headerlink" title="1.网络地址转换技术的背景"></a>1.网络地址转换技术的背景</h3><p>研究<strong>网络地址转换（NAT）</strong>技术处于两个目的：一是由于IPv4过渡到IPv6的进程很缓慢，因此需要一种短时间内有效缓解IP地址短缺的办法，那就是网络地址转换（NAT）技术。二是出于网络安全的目的。例如，在某些企业内部、政府部门专网等对Internet访问需要严格控制的内部网络系统中，NAT与代理服务器、防火墙技术结合起来使用，采用一个内部专用IP地址与一个全局IP地址一对一对应的静态映射方式，达到隐藏内部网络地址的目的。</p>
<h3 id="2-网络地址转换的工作原理"><a href="#2-网络地址转换的工作原理" class="headerlink" title="2.网络地址转换的工作原理"></a>2.网络地址转换的工作原理</h3><p>NAT用来将内网地址和端口号转换成合法的公网地址和端口号，建立一个会话，与公网主机进行通信。</p>
<p>NTA外部的主机无法主动跟位于NAT内部的主机通信，NAT内部主机想要通信，必须主动和公网的一个IP通信，路由器负责建立一个映射关系，从而实现数据的转发。<br><img src="https://pic3.zhimg.com/80/v2-817864a931d3a33b8be5055f2bfc99fe_720w.jpg"></p>
<p>数据包从内网到外网时，会转换源lP地址，由私网地址转换成公网地址。</p>
<p>数据包从外网到内网时，会转换目的IP地址，由公网地址转换成私网地址。</p>
<h3 id="3-网络地址转换方法的作用"><a href="#3-网络地址转换方法的作用" class="headerlink" title="3.网络地址转换方法的作用"></a>3.网络地址转换方法的作用</h3><p>讨论了有关因特网地址和IPv4数据报格式后，我们现在可清楚地认识到每个IP使能的设备都需要一个IP地址。随着所谓小型办公室、家庭办公室 (Small Office，HomeOffice，SOHO）子网的大量出现，看起来意味着每当一个SOHO想安装一个LAN以互联多台机器时，需要ISP分配一组地址以供该SOHO的所有IP设备（包括电话、平板电脑、游戏设备、IP TV、打印机等）使用。</p>
<p>如果该子网变大了，则需要分配一块较大的地址。但如果 ISP已经为SOHO网络的当前地址范围分配过一块连续地址该怎么办呢?并且，家庭主人一般要（或应该需要）首先知道的管理IP地址的典型方法有哪些呢?幸运的是,有一种简单的方法越来越广泛地用在这些场合:网络地址转换(Network Address Transla-tion，NAT)[RFC 2663;RFC 3022;Huston 2004;Zhang 2007;Cisco NAT 2016]。</p>
<h3 id="4-网络地址转换方法的例子"><a href="#4-网络地址转换方法的例子" class="headerlink" title="4.网络地址转换方法的例子"></a>4.网络地址转换方法的例子</h3><p>图4-25显示了一台NAT使能路由器的运行情况。位于家中的NAT使能的路由器有一个接口，该接口是图4-25中右侧所示家庭网络的一部分。在家庭网络内的编址就像我们在上面看到的完全一样，其中的所有4个接口都具有相同的网络地址10.0.0&#x2F;24。地址空间10.0.0.0&#x2F;8是在〔RFC 1918]中保留的三部分IP地址空间之一，这些地址用于如图4-25中的家庭网络等专用网络( private network）或具有专用地址的地域( realm with privateaddress)。具有专用地址的地域是指其地址仅对该网络中的设备有意义的网络。</p>
<p>为了明白它为什么重要，考虑有数十万家庭网络这样的事实，许多使用了相同的地址空间10.0. 0.0&#x2F;24。在一个给定家庭网络中的设备能够使用10.0.0.0&#x2F;24编址彼此发送分组。然而，转发到家庭网络之外进入更大的全球因特网的分组显然不能使用这些地址（或作为源地址，或作为目的地址)，因为有数十万的网络使用着这块地址。这就是说，10.0.0.0&#x2F;24地址仅在给定的网络中才有意义。但是如果专用地址仅在给定的网络中才有意义的话，当向或从全球因特网发送或接收分组时如何处理编址问题呢，地址在何处才必须是唯一的呢?答案在于理解NAT。<br><img src="https://pic2.zhimg.com/80/v2-57912bc5b96477a791b9774e923847c9_720w.jpg"></p>
<p>如果从广域网到达NAT路由器的所有数据报都有相同的目的IP地址（特别是对NAT路由器广域网一侧的接口)，那么该路由器怎样知道它应将某个分组转发给哪个内部主机呢?技巧就是使用NAT路由器上的一张 NAT转换表（NAT translation table)，并且在表项中包含了端口号及其IP地址。</p>
<p>考虑图4-25中的例子。假设一个用户坐在家庭网络主机10.0.0.1后，请求IP地址为128.119.40.186的某台Web 服务器（端口80）上的一个Web页面。主机10.0.0.1为其指派了(任意）源端口号3345并将该数据报发送到LAN中。NAT路由器收到该数据报，为该数据报生成一个新的源端口号5001，将源IP替代为其广域网一侧接口的IP地址138.76.29.7，且将源端口3345更换为新端口5001。当生成一个新的源端口号时，NAT路由器可选择任意一个当前未在NAT转换表中的源端口号。(注意到因为端口号字段为16比特长，NAT协议可支持超过60000个并行使用路由器广域网一侧单个IP地址的连接!)路由器中的NAT也在它的NAT转换表中增加一表项。Web服务器并不知道刚到达的包含HTTP请求的数据报已被NAT路由器进行了改装，它会发回一个响应报文，其目的地址是NAT路由器的IP地址，其目的端口是5001。当该报文到达NAT路由器时，路由器使用目的IP地址与目的端口号从 NAT转换表中检索出家庭网络浏览器使用的适当IP地址(10.0.0. 1）和目的端口号(3345)。于是，路由器重写该数据报的目的IP地址与目的端口号，并向家庭网络转发该数据报。</p>
<p>NAT使路由器对于外部世界来说甚至不像一台路由器。相反 NAT路由器对外界的行为就如同一个具有单一IP地址的单一设备。在图4-25中，所有离开家庭路由器流向更大因特网的报文都拥有一个源IP地址138.76.29.7，且所有进入家庭的报文都拥有同一个目的IP地址138.76.29.7。</p>
<p>从本质上讲，NAT使能路由器对外界隐藏了家庭网络的细节。</p>
<h3 id="5-对网络地址转换方法的评价"><a href="#5-对网络地址转换方法的评价" class="headerlink" title="5.对网络地址转换方法的评价"></a>5.对网络地址转换方法的评价</h3><p>尽管NAT对于IP地址短缺问题是一种很实用的方法也得到了广泛的应用。但是NAT并非没有批评者。</p>
<p>这些意见主要可以总结为以下三点：</p>
<p>（1）NAT违反了IP设计的初衷，使IP从无连接变成面向连接；在网络层IP地址转换的同时转换传输层端口号，违反了网络体系结构设计中确定的不同层次之间相互独立的原则。</p>
<p>（2）有些应用将IP地址插入在正文内容中。如果NAT与这类协议一起工作，NAT协议需要根据不同协议做不同的调整。</p>
<p>（3）由于P2P的文件共享与语音共享是建立在IP的基础上的，NAT的存在，使得P2P实现出现困难。</p>
<p>NAT的反对者认为这种临时性的缓解IP地址短缺的方案只是推迟了IPv6迁移的过程，而没有解决深层次的问题。</p>
<p>对IPv4协议的一些基本概念的整理到此结束。</p>
<p>本文内容参考自维基百科、《计算机网络自顶向下方法第七版》、《计算机网络（吴功宜）第4版》。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>抓包</tag>
        <tag>IP协议</tag>
        <tag>IPv4</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（六）Linux C++ Socket实现并发TCP服务器（fork）</title>
    <url>/archives/1815c365.html</url>
    <content><![CDATA[<p>本文使用fork函数实现并发TCP服务器，关于fork函数的用法可以参考我的文章：<br><a href="https://raidenxe.github.io/archives/90acc1af.html">Linux 下的 fork 和 exec 函数</a></p>
<h1 id="服务器基本结构"><a href="#服务器基本结构" class="headerlink" title="服务器基本结构"></a>服务器基本结构</h1><p>本文的目标是编写一个完整的TCP客户&#x2F;服务器程序示例。这个简单的例子是执行如下步骤的一个回射服务器:</p>
<p>(1) 客户从标准输入读入一行文本，并写给服务器;</p>
<p>(2) 服务器从网络输入读入这行文本，并回射给客户;</p>
<p>(3) 客户从网络输入读入这行回射文本，并显示在标准输出上。</p>
<p>结构如下：<br><img src="https://pic3.zhimg.com/80/v2-7c83c25ffa290ff2fb8b07310ace85f6_720w.jpg"></p>
<h1 id="迭代服务器和并发服务器"><a href="#迭代服务器和并发服务器" class="headerlink" title="迭代服务器和并发服务器"></a>迭代服务器和并发服务器</h1><p><strong>迭代服务器</strong>以串行方式一次处理一个客户端。</p>
<p><strong>迭代服务器</strong>会依次处理客户端的连接 ，只要当前连接的任务没有完成，服务器的进程就会一直被占用，直到任务完成后，服务器关闭这个socket，释放连接。</p>
<p><strong>并发服务器</strong>：服务器可以是迭代的，即它遍历每个客户端并一次服务一个请求。</p>
<p>或者，一台服务器可以同时并行处理多个客户端，这种类型的服务器称为并发服务器。</p>
<p>并发服务器主要通过三种方式：进程、线程和IO复用来分别实现。</p>
<h2 id="迭代服务器程序轮廓"><a href="#迭代服务器程序轮廓" class="headerlink" title="迭代服务器程序轮廓"></a>迭代服务器程序轮廓</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> listenfd,connfd;</span><br><span class="line"> listenfd = socket( ... );</span><br><span class="line"> bind(listen, ... );</span><br><span class="line"> listen(listenfd,LISTENQ);</span><br><span class="line"> <span class="keyword">for</span>(;;)</span><br><span class="line"> &#123;</span><br><span class="line"> connfd = accept(listenfd, ... ); </span><br><span class="line"> doit(connfd);</span><br><span class="line"> close(connfd);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发服务器程序轮廓"><a href="#并发服务器程序轮廓" class="headerlink" title="并发服务器程序轮廓"></a>并发服务器程序轮廓</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> listenfd,connfd;</span><br><span class="line">listenfd = socket( ... );</span><br><span class="line">bind(listen, ... );</span><br><span class="line">listen(listenfd,LISTENQ);</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">connfd = accept(listenfd, ... );</span><br><span class="line"><span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(listenfd);</span><br><span class="line">doit(connfd);</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发服务器的运行流程"><a href="#并发服务器的运行流程" class="headerlink" title="并发服务器的运行流程"></a>并发服务器的运行流程</h2><p>我们在同一个主机上启动客户，并指定服务器主机的IP地址为127.0.0.1（环回地址)。当然我们也可以指定该地址为该主机的普通（非环回）IP地址。</p>
<p>客户调用socket和connect，后者引起TCP的三路握手过程。当三路握手完成后，客户中的connect和服务器中的accept均返回，连接于是建立。接着发生的步骤如下:</p>
<p>(1)客户调用send函数，该函数将阻塞于fgets调用，因为我们还未曾键入过一行文本。</p>
<p>(2)当服务器中的accept返回时，服务器调用fork，再由子进程调用write函数返回输入信息。调用read，而read在等待客户送入一行文本期间阻塞。</p>
<p>(3)另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。</p>
<p>至此，我们有3个都在睡眠（即已阻塞）的进程:客户进程、服务器父进程和服务器子进程。</p>
<p>至此连接已经建立，不论我们在客户的标准输入中键入什么，都会回射到它的标准输出中。</p>
<h1 id="POSIX信号处理"><a href="#POSIX信号处理" class="headerlink" title="POSIX信号处理"></a>POSIX信号处理</h1><p><strong>信号</strong>(signal）就是告知某个进程发生了某个事件的通知，有时也称为软件中断( softwareinterrupt)。信号通常是异步发生的，也就是说进程预先不知道信号的准确发生时刻。</p>
<p>信号可以:</p>
<p>由一个进程发给另一个进程（或自身)；</p>
<p>由内核发给某个进程。</p>
<p>上一节结尾提到的SIGCHLD信号就是由内核在任何一个进程终止时发给它的父进程的一个信号。</p>
<p>（1）每个信号都有一个与之关联的处置( disposition)，也称为行为(action)。我们通过调用sigaction函数（稍后讨论）来设定一个信号的处置，并有三种选择。</p>
<p>我们可以提供一个函数，只要有特定信号发生它就被调用。这样的函数称为信号处理函数( signal handler),这种行为称为捕获( catching)信号。有两个信号不能被捕获，它们是SIGKILL和SIGSTOP。信号处理函数由信号值这个单一的整数参数来调用，且没有返回值，其函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span> <span class="params">( <span class="type">int</span> signo)</span> ;</span><br></pre></td></tr></table></figure>
<p>对于大多数信号来说，调用sigaction函数并指定信号发生时所调用的函数就是捕获信号所需做的全部工作。不过我们稍后将看到，SIGIO、SIGPoLL和SIGURG这些个别信号还要求捕获它们的进程做些额外工作。</p>
<p>(2)我们可以把某个信号的处置设定为STG_IG来忽略(ignore）它。SIGKILL和STGSTOP这两个信号不能被忽略。</p>
<p>(3)我们可以把某个信号的处置设定为SIG_DFL来启用它的默认(default）处置。默认处置通常是在收到信号后终止进程,其中某些信号还在当前工作目录产生一个进程的核心映像(coreimage，也称为内存影像)。另有个别信号的默认处置是忽略，SIGCHLD和SIGURG（带外数据到达时发送，见第24章）就是本书中出现的默认处置为忽略的两个信号。</p>
<h2 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h2><p>建立信号处置的POSIX方法就是调用sigaction函数。不过这有点复杂，因为该函数的参数之一是我们必须分配并填写的结构。简单些的方法就是调用signal函数，其第一个参数是信号名，第二个参数或为指向函数的指针，或为常值SIG_IGN或STIG_DFL。然而signal是早于POSIX出现的历史悠久的函数。调用它时，不同的实现提供不同的信号语义以达成后向兼容，而POSIX则明确规定了调用sigaction时的信号语义。我们的解决办法是定义自己的signal函数，它只是调用POSIX的sigaction函数。这就以所期望的POSIX语义提供了一个简单的接口。</p>
<p>函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sighandler_tsignal(int__sig, sighandler_t__handler)</span><br></pre></td></tr></table></figure>
<p>第一个参数-信号类型共有64个，通过在终端键入 kill -l查看。<br><img src="https://pic2.zhimg.com/80/v2-18461fd503682cac3b1721b9c92c8195_720w.jpg"></p>
<p>第二个参数是捕获到该信号的处理方式，这里我们选择自己定义对于信号的反应函数，即下文的处理僵死进程。</p>
<p>这里我们选择使用SIGCHLD信号。（其他信号类型和作用，这里就不作赘述了）</p>
<p>其作用是：进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略。</p>
<h2 id="如何处理SIGCHLD信号"><a href="#如何处理SIGCHLD信号" class="headerlink" title="如何处理SIGCHLD信号"></a>如何处理SIGCHLD信号</h2><p>设置僵尸（zombie）状态的目的是维护子进程的信息，以便于父进程在某个时刻获取。这里面包含：子进程的进程ID、终止状态以及资源利用信息（CPU时间、内存使用量）。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程会变成init进程，进程ID&#x3D;1。init进程会清理（wait）这些僵尸进程。</p>
<h1 id="处理僵死进程"><a href="#处理僵死进程" class="headerlink" title="处理僵死进程"></a>处理僵死进程</h1><p>我们显然不愿意留存僵死进程。它们占用内核中的空间，最终可能导致我们耗尽进程资源。无论何时我们fork子进程都得wait它们，以防它们变成僵死进程。为此我们建立一个俘获SIGCHLD信号的信号处理函数，在函数体中我们调用wait。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal (SIGCHLD,sig_chld) ;</span><br></pre></td></tr></table></figure>
<p>我们就建立了该信号处理函数。(这必须在fork第一个子进程之前完成，且只做一次。）我们接着定义名为sig__chld的这个信号处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_chld</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="type">int</span> stat;</span><br><span class="line"> <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>,&amp;stat,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;child &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot; termination&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statloc)</span> ;</span><br><span class="line">pid.t <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid ,<span class="type">int</span> *statioc,<span class="type">int</span> options )</span> ;</span><br><span class="line"><span class="comment">//均返回:若成功则为进程D，若出错则为O或-1</span></span><br></pre></td></tr></table></figure>

<h2 id="wait函数的原理："><a href="#wait函数的原理：" class="headerlink" title="wait函数的原理："></a>wait函数的原理：</h2><p>进程调用wait，然后阻塞自己，然后寻找僵尸子进程，找到了则销毁子进程然后返回，没有找到则一直阻塞直到找到僵尸子进程为止。</p>
<h2 id="waitpid函数："><a href="#waitpid函数：" class="headerlink" title="waitpid函数："></a>waitpid函数：</h2><h3 id="pid参数："><a href="#pid参数：" class="headerlink" title="pid参数："></a>pid参数：</h3><p>1)pid&gt;0:只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束,waitpid就会一直等下去<br>2)pid&#x3D;-1:等待任何一个子进程，没有限制，此时和wait函数作用一模一样<br>3）pid&lt;-1：等待一个指定进程组中的任何子进程，进程组号&#x3D;pid的绝对值<br>4）pid&#x3D;0：等待一个指定进程组中的任何子进程，进程组号为pid的值   </p>
<h3 id="options参数"><a href="#options参数" class="headerlink" title="options参数:"></a>options参数:</h3><p>1)options&#x3D;WNOHANG,即使子进程没有退出，它也会立即返回，不会像wait那样永远等下去<br>2）options&#x3D;WUNTRECED，子进程睡眠则马上返回，但结束状态不予理会<br>3）options&#x3D;0，不使用该参数<br>和wait函数相比，waitpid其实是wait函数的封装，waitpid可以指定等待的子进程，并且指定返回的条件。</p>
<h2 id="wait和waitpid函数的用法"><a href="#wait和waitpid函数的用法" class="headerlink" title="wait和waitpid函数的用法"></a>wait和waitpid函数的用法</h2><p>函数wait和waitpid均返回两个值:已终止子进程的进程ID号，以及通过statloc指针返回的子进程终止状态（一个整数)。</p>
<p>我们可以调用三个宏来检查终止状态，并辨别子进程是正常终止、由某个信号杀死还是仅仅由作业控制停止而已。另有些宏用于接着获取子进程的退出状态、杀死子进程的信号值或停止子进程的作业控制信号值。</p>
<p>如果调用wait的进程没有已终止的子进程，不过有一个或多个子进程仍在执行，那么wait将阻塞到现有子进程第一个终止为止。</p>
<p>waitpid函数就等待哪个进程以及是否阻塞给了我们更多的控制。首先，pid参数允许我们指定想等待的进程ID，值-1表示等待第一个终止的子进程。(另有一些处理进程组ID的可选值，不过本书中用不上。）其次，options参数允许我们指定附加选项。最常用的选项是WNOHANG，它告知内核在没有已终止子进程时不要阻塞。</p>
<h2 id="wait和waitpid的区别"><a href="#wait和waitpid的区别" class="headerlink" title="wait和waitpid的区别"></a>wait和waitpid的区别</h2><p>waitpid采用了WNOHANG参数，所以waitpid不会阻塞，也就是说父进程不会阻塞在那里等待子进程返回，它会立即返回然后去做自己的事情，所以需要加个循环直到等待到进程为止，相当于轮询。</p>
<p>而在一些情况下，比如同一信号多个实例的递交，建立一个信号处理函数并在其中调用wait并不足以防止出现僵死进程。</p>
<p>正确的解决办法是调用waitpia而不是wait。原因在于，我们在一个循环内调用waitpid，以获取所有已终止子进程的状态。我们必须指定WNOHANG选项，它告知waitpid在有尚未终止的子进程在运行时不要阻塞。我们不能在循环内调用wait，因为没有办法防止wait在正运行的子进程尚有未终止时阻塞。</p>
<h1 id="并发TCP服务器代码实现"><a href="#并发TCP服务器代码实现" class="headerlink" title="并发TCP服务器代码实现"></a>并发TCP服务器代码实现</h1><p>server.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 7000</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_chld</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="type">int</span> stat;</span><br><span class="line"> <span class="keyword">while</span>((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>,&amp;stat,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;child &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot; termination&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> serv_sockfd;</span><br><span class="line"> <span class="type">int</span> client_sockfd;</span><br><span class="line"> </span><br><span class="line"> <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"> <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in">sizeof</span>(buf));</span><br><span class="line"> </span><br><span class="line"> sockaddr_in serv_addr;</span><br><span class="line"> sockaddr_in client_addr;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"> serv_addr.sin_family = AF_INET;</span><br><span class="line"> serv_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"> serv_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>((serv_sockfd = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="number">0</span>))&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;socket error&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>((<span class="built_in">bind</span>(serv_sockfd,(sockaddr *)&amp;serv_addr,<span class="built_in">sizeof</span>(serv_addr)))&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;bind error&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>((<span class="built_in">listen</span>(serv_sockfd,<span class="number">5</span>))&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;listen error&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;listening...&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">signal</span>(SIGCHLD,sig_chld);</span><br><span class="line"> </span><br><span class="line"> <span class="type">socklen_t</span> sin_size;</span><br><span class="line"> <span class="type">int</span> read_len=<span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> child_pid;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> sin_size = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"> <span class="built_in">memset</span>(&amp;client_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(client_addr));</span><br><span class="line"> <span class="keyword">if</span>((client_sockfd = <span class="built_in">accept</span>(serv_sockfd,(sockaddr*)&amp;client_addr,&amp;sin_size))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"> <span class="keyword">if</span>(errno == EINTR || errno == ECONNABORTED)</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;accept error&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>((child_pid = fork())==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;client &quot;</span> &lt;&lt;<span class="built_in">inet_ntoa</span>(client_addr.sin_addr) &lt;&lt; <span class="string">&quot; 进程号：&quot;</span>&lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">write</span>(client_sockfd,<span class="string">&quot;Welcome to my server\n&quot;</span>,<span class="number">21</span>);</span><br><span class="line"> <span class="built_in">close</span>(serv_sockfd);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in">sizeof</span>(buf));</span><br><span class="line"> <span class="keyword">if</span>((read_len = <span class="built_in">read</span>(client_sockfd,buf,BUF_SIZE))&lt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line"> <span class="built_in">close</span>(client_sockfd);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-5</span>);</span><br><span class="line">                &#125;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Client&quot;</span>&lt;&lt; <span class="built_in">getpid</span>()  &lt;&lt; <span class="string">&quot; say:&quot;</span>&lt;&lt;buf &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">write</span>(client_sockfd,buf,read_len);</span><br><span class="line">            &#125;</span><br><span class="line"> <span class="built_in">close</span>(client_sockfd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-6</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(child_pid&gt;<span class="number">0</span>)</span><br><span class="line"> <span class="built_in">close</span>(client_sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>客户端程序可以参考我的另一篇文章：<br><a href="https://raidenxe.github.io/archives/7a099087.html">计算机网络知识点总结（三）Socket 基本函数详解，C++ Socket 入门实战</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Socket</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结（四）Linux C++ Socket实现“伪”半双工聊天室程序</title>
    <url>/archives/cf06f66d.html</url>
    <content><![CDATA[<p>在上文中，讲述了Socket的一些基本函数以及如何简单使用Socket搭建一个单工聊天的聊天室程序。</p>
<p>本文的目标便是对这个简单的程序加以改进，使其能实现服务端和客户端之间的相互通信。如果想更深入理解，推荐大家阅读《UNIX网络编程卷1套接字联网API》这本书。</p>
<h2 id="首先需要补充一些我之前没有提到过的知识点。"><a href="#首先需要补充一些我之前没有提到过的知识点。" class="headerlink" title="首先需要补充一些我之前没有提到过的知识点。"></a>首先需要补充一些我之前没有提到过的知识点。</h2><h3 id="Socket处于网络协议的哪个层次？"><a href="#Socket处于网络协议的哪个层次？" class="headerlink" title="Socket处于网络协议的哪个层次？"></a>Socket处于网络协议的哪个层次？</h3><p><img src="https://pic4.zhimg.com/80/v2-728b741914df045b9cdfb918a30d1843_720w.jpg" alt="socket网络层次"><br>套接字编程接口是从顶上三层（网际协议的应用层）进入传输层的接口。</p>
<h3 id="为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口"><a href="#为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口" class="headerlink" title="为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口?"></a>为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口?</h3><p>这样设计有两个理由，如图1-14右侧所注。理由之一是顶上三层处理具体网络应用（如FTP、Telnet或HTTPO的所有细节，却对通信细节了解很少;底下四层对具体网络应用了解不多，却处理所有的通信细节:发送数据，等待确认，给无序到达的数据排序，计算并验证校验和，等等。理由之二是顶上三层通常构成所谓的用户进程user process口,底下四层却通常作为操作系统内核的一部分提供。Unix与其他现代操作系统都提供分隔用户进程与内核的机制。由此可见，第4层和第5层之间的接口是构建API的自然位置。</p>
<h2 id="TCP实现框架"><a href="#TCP实现框架" class="headerlink" title="TCP实现框架"></a>TCP实现框架</h2><p><img src="https://pic1.zhimg.com/80/v2-dfaeec3f74165f5a74c278a513d54ab8_720w.jpg" alt="TCP实现框架"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>目前该代码尚不完善，仅供参考，只能实现一发送一接收的“伪”半双工通信。真正的半双工(Half Duplex)数据传输，数据可以随时发送，只是不能同时传输。</p>
<h2 id="Sever-cpp"><a href="#Sever-cpp" class="headerlink" title="Sever.cpp"></a>Sever.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 7000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024 <span class="comment">//缓冲区大小宏定义</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"> <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]); <span class="comment">//将输入的端口号由字符串转换为整数类型</span></span><br><span class="line">    <span class="comment">//结构体定义与初始化</span></span><br><span class="line"> <span class="type">int</span> sockSer = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//若成功则返回一个sockfd（套接字描述符）</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_sockaddr;            <span class="comment">//一般是储存地址和端口的。用于信息的显示及存储使用</span></span><br><span class="line">                                                   <span class="comment">//设置 sockaddr_in 结构体中相关参数</span></span><br><span class="line"> server_sockaddr.sin_family = AF_INET;</span><br><span class="line"> server_sockaddr.sin_port = <span class="built_in">htons</span>(PORT); <span class="comment">//将一个无符号短整型数值转换为网络字节序，即大端模式(big-endian) </span></span><br><span class="line">                                            <span class="comment">// printf(&quot;%d\n&quot;,INADDR_ANY);</span></span><br><span class="line">    <span class="comment">// INADDR_ANY就是指定地址为0.0.0.0的地址，这个地址事实上表示不确定地址，或“所有地址”、“任意地址”。</span></span><br><span class="line">    <span class="comment">//一般来说，在各个系统中均定义成为0值。</span></span><br><span class="line">    <span class="comment">// server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); //将主机的无符号长整形数转换成网络字节顺序。</span></span><br><span class="line"> <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;server_sockaddr.sin_addr); <span class="comment">//将小端字节序转换为网络字节序</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">assert</span>(sockSer &gt;= <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> ret = <span class="built_in">bind</span>(sockSer, (<span class="keyword">struct</span> sockaddr *)&amp;server_sockaddr, <span class="built_in">sizeof</span>(server_sockaddr)); <span class="comment">//绑定IP地址、端口号等信息</span></span><br><span class="line"> <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"> ret = <span class="built_in">listen</span>(sockSer, <span class="number">5</span>); <span class="comment">//监听有无连接请求</span></span><br><span class="line"> <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line"> <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="comment">///成功返回非负描述字，出错返回-1</span></span><br><span class="line"> <span class="type">int</span> connfd = <span class="built_in">accept</span>(sockSer, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_addrlength); <span class="comment">//从监听队列中取出第一个已完成的连接</span></span><br><span class="line"> <span class="type">char</span> buffer_recv[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">char</span> buffer_send[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;errno is : %d\n&quot;</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"> <span class="built_in">memset</span>(buffer_recv, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line"> <span class="built_in">memset</span>(buffer_send, <span class="number">0</span>, BUFFER_SIZE); <span class="comment">//每次需要为缓冲区清空</span></span><br><span class="line"> </span><br><span class="line"> ret = <span class="built_in">recv</span>(connfd, buffer_recv, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer_recv, <span class="string">&quot;quit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Communications is over!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">// recv为quit表示客户端请求断开连接，退出循环</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;client:%s&quot;</span>, buffer_recv);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;server:&quot;</span>);</span><br><span class="line"> <span class="built_in">fgets</span>(buffer_send, BUFFER_SIZE, stdin);</span><br><span class="line"> <span class="built_in">send</span>(connfd, buffer_send, <span class="built_in">strlen</span>(buffer_send), <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer_send, <span class="string">&quot;quit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Communications is over!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">// send为quit表示服务器请求断开连接，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">close</span>(connfd);</span><br><span class="line"> <span class="built_in">close</span>(sockSer); <span class="comment">//关闭socket套接字描述符</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client-cpp"><a href="#Client-cpp" class="headerlink" title="Client.cpp"></a>Client.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"> <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> sockCli = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"> <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"> servaddr.sin_family = AF_INET;</span><br><span class="line"> servaddr.sin_port = <span class="built_in">htons</span>(port); <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="comment">// servaddr.sin_addr.s_addr = htons(port);</span></span><br><span class="line"> <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;servaddr.sin_addr); <span class="comment">//将点分文本的IP地址转换为二进制网络字节序的IP地址</span></span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> sockfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">assert</span>(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> connfd = <span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"> </span><br><span class="line"> <span class="type">char</span> sendbuf[BUFFER_SIZE];</span><br><span class="line"> <span class="type">char</span> recvbuf[BUFFER_SIZE];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"> <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line"> <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;client:&quot;</span>);</span><br><span class="line"> <span class="built_in">fgets</span>(sendbuf, BUFFER_SIZE, stdin);</span><br><span class="line"> <span class="built_in">send</span>(sockfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(sendbuf, <span class="string">&quot;quit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Communications is over!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">//send为quit表示客户端请求断开连接，退出循环</span></span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, recvbuf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(recvbuf, <span class="string">&quot;quit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Communications is over!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">//recv为quit表示服务器请求断开连接，退出循环</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;server:%s&quot;</span>, recvbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="built_in">close</span>(connfd);</span><br><span class="line"> <span class="built_in">close</span>(sockCli);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
        <tag>Socket</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点（五） I/O 多路复用：函数select、poll和epoll</title>
    <url>/archives/884564f6.html</url>
    <content><![CDATA[<h1 id="什么是IO多路复用？"><a href="#什么是IO多路复用？" class="headerlink" title="什么是IO多路复用？"></a>什么是IO多路复用？</h1><p>IO即为网络I&#x2F;O，多路即为多个TCP连接，复用即为共用一个线程或者进程，模型最大的优势是系统开销小，不必创建也不必维护过多的线程或进程。</p>
<p>IO复用(IOmultiplexing)使得内核一旦发现进程指定的一个或多个IO条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出)，它就通知进程。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>I&#x2F;O 多路复用通常用于以下场景的网络应用：</p>
<p>当客户端处理多个描述符时（通常是交互式输入和网络套接字）</p>
<p>当客户端同时处理多个套接字时（这是可能的，但很少见）</p>
<p>如果 TCP 服务器同时处理侦听套接字及其连接的套接字</p>
<p>如果服务器同时处理 TCP 和 UDP</p>
<p>如果服务器处理多个服务，可能还有多个协议</p>
<p>I&#x2F;O 多路复用不限于网络编程。许多重要的应用程序发现需要这些技术。</p>
<h1 id="输入-x2F-输出模型"><a href="#输入-x2F-输出模型" class="headerlink" title="输入&#x2F;输出模型"></a>输入&#x2F;输出模型</h1><p>我们首先检查 Unix 下可用的五种 I&#x2F;O 模型的基本区别：</p>
<p><strong>[1]blockingIO - 阻塞I&#x2F;O</strong></p>
<p><strong>[2]nonblockingIO - 非阻塞I&#x2F;O</strong></p>
<p><strong>[3]IOmultiplexing – I&#x2F;O多路复用（select和poll）</strong></p>
<p><strong>[4]signaldrivenIO - 信号驱动I&#x2F;O</strong></p>
<p><strong>[5]asynchronousIO - 异步I&#x2F;O（POSIX aio函数）</strong></p>
<h2 id="输入操作通常有两个不同的阶段："><a href="#输入操作通常有两个不同的阶段：" class="headerlink" title="输入操作通常有两个不同的阶段："></a>输入操作通常有两个不同的阶段：</h2><p>1等待数据准备好。这涉及等待数据到达网络。当数据包到达时，它被复制到内核中的缓冲区中。</p>
<p>2将数据从内核复制到进程。这意味着将（准备好的）数据从内核缓冲区复制到我们的应用程序缓冲区</p>
<h1 id="阻塞-I-x2F-O-模型"><a href="#阻塞-I-x2F-O-模型" class="headerlink" title="阻塞 I&#x2F;O 模型"></a>阻塞 I&#x2F;O 模型</h1><p>最流行的 I&#x2F;O 模型是阻塞 I&#x2F;O 模型（我们在前面部分的所有示例中都使用了该模型）。默认情况下，所有套接字都是阻塞的。场景如下图所示：<br><img src="https://pic4.zhimg.com/80/v2-728b741914df045b9cdfb918a30d1843_720w.jpg" alt="阻塞I/O模型"></p>
<p>使用UDP而不是TCP作为例子的原因在于就UDP而言，数据准备好读取的概念比较简单:要么整个数据报已经收到，要么还没有。然而对于TCP来说，诸如套接字低水位标记( low-water mark）等额外变量开始起作用，导致这个概念变得复杂。</p>
<p>在这个例子中,我们把recvfrom函数视为系统调用,因为我们正在区分应用进程和内核。不论它如何实现(在源自Berkeley的内核上是作为系统调用，在System V内核上是作为调用系统调用getmsg的函数)，一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间之后再切换回来。</p>
<h1 id="非阻塞-I-x2F-O-模型"><a href="#非阻塞-I-x2F-O-模型" class="headerlink" title="非阻塞 I&#x2F;O 模型"></a>非阻塞 I&#x2F;O 模型</h1><p>当套接字设置为非阻塞时，我们是在告诉内核“当我请求的 I&#x2F;O 操作在不让进程进入睡眠状态的情况下无法完成时，不要让进程进入睡眠状态，而是返回一个错误”。</p>
<p><img src="https://pic3.zhimg.com/80/v2-fb59340a9864676a60e9bdcfbd523dca_720w.jpg" alt="非阻塞I/O模型"><br>对于前三个recvfrom，没有要返回的数据，内核立即返回一个错误EWOULDBLOCK。<br>我们第四次调用recvfrom，数据报准备好了，它被复制到我们的应用程序缓冲区，并recvfrom成功返回。然后我们处理数据。<br>当应用程序处于循环调用recvfrom这样的非阻塞描述符时，它被称为轮询。应用程序不断地轮询内核以查看某些操作是否已准备好。这通常会浪费 CPU 时间，但偶尔会遇到这种模型，通常在专用于一个功能的系统上。</p>
<h1 id="I-x2F-O-复用模型"><a href="#I-x2F-O-复用模型" class="headerlink" title="I&#x2F;O 复用模型"></a>I&#x2F;O 复用模型</h1><p>有了IO复用(IO multiplexing)，我们就可以调用select或poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。</p>
<p><img src="https://pic2.zhimg.com/80/v2-824e9b31fc2e72d02956b72dc622c751_720w.jpg" alt="IO复用"></p>
<p>我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据报复制到应用进程缓冲区。</p>
<p>与阻塞型IO比较，IO复用并不显得有什么优势，事实上由于使用select需要两个而不是单个系统调用，IO复用还稍有劣势。，使用select的优势在于我们可以等待多个描述符就绪。</p>
<h1 id="异步-I-x2F-O-模型"><a href="#异步-I-x2F-O-模型" class="headerlink" title="异步 I&#x2F;O 模型"></a>异步 I&#x2F;O 模型</h1><p>异步 I&#x2F;O由 POSIX 规范定义，各种标准中出现的实时功能的各种差异共同形成了当前的 POSIX 规范。</p>
<p>我们也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们。我们称这种模型为信号驱动式IO ( signal-driven I&#x2F;O)。</p>
<p><img src="https://pic1.zhimg.com/80/v2-dc3e4fbed4a71e550f0b422e268b70a8_720w.jpg" alt="异步IO"></p>
<p>我们首先开启套接字的信号驱动式I&#x2F;O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个sIGIo信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。</p>
<p>无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知:既可以是数据已准备好被处理，也可以是数据报已准备好被读取。</p>
<h1 id="各种I-x2F-O模型的比较"><a href="#各种I-x2F-O模型的比较" class="headerlink" title="各种I&#x2F;O模型的比较"></a>各种I&#x2F;O模型的比较</h1><p>对比上述5种不同的IO模型。可以看出，前4种模型的主要区别在于第一阶段，因为它们的第二阶段是一样的:在数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom调用。相反，异步I&#x2F;O模型在这两个阶段都要处理，从而不同于其他4种模型。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e393476a5386a92c319e5e163166fc53_720w.jpg" alt="IO模型比较"></p>
<h1 id="同步IO和异步IO对比"><a href="#同步IO和异步IO对比" class="headerlink" title="同步IO和异步IO对比"></a>同步IO和异步IO对比</h1><p>POSIX把这两个术语定义如下:</p>
<p>同步IO操作(synchronous IO opetation）导致请求进程阻塞，直到IO操作完成;</p>
<p>异步IO操作（ asynchronous I&#x2F;O opetation）不导致请求进程阻塞。<br><img src="https://pic4.zhimg.com/80/v2-2c642bd2b7ef29542c3145e221cd2f97_720w.jpg"></p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>select 是操作系统提供的系统调用函数，select()用来等待文件描述词（普通文件、终端、伪终端、管道、FIFO、套接字及其他类型的字符型）状态的改变。是一个轮循函数，循环询问文件节点，可设置超时时间，超时时间到了就跳过代码继续往下执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">​<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数据结构 (bitmap)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">int</span> max_fd, </span></span></span><br><span class="line"><span class="params"><span class="function"> fd_set *readset, </span></span></span><br><span class="line"><span class="params"><span class="function"> fd_set *writeset, </span></span></span><br><span class="line"><span class="params"><span class="function"> fd_set *exceptset, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">struct</span> timeval *timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="comment">// 返回值就绪描述符的数目</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span> <span class="comment">// 清空集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span> <span class="comment">// 将给定的描述符加入集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span> <span class="comment">// 判断指定描述符是否在集合中 </span></span></span><br><span class="line"><span class="function"><span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span> <span class="comment">// 将给定的描述符从文件中删除 </span></span></span><br></pre></td></tr></table></figure>
<p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p>
<p>一般来说这个数目和系统内存关系很大，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看。32位机默认是1024个。64位机默认是2048。</p>
<p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p>
<p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。</p>
<p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p>
<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>相关函数定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">ppoll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> <span class="keyword">struct</span> timespec *tmo_p, <span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line"> <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line"> <span class="type">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line"> <span class="type">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>和select用三组文件描述符不同的是，poll只有一个pollfd数组，数组中的每个元素都表示一个需要监听IO操作事件的文件描述符。events参数是我们需要关心的事件，revents是所有内核监测到的事件。</p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>它没有最大连接数的限制</strong>，原因是它是基于链表来存储的，但是同样有一个缺点：</p>
<p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</p>
<p>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>相关函数定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> maxevents, <span class="type">int</span> timeout,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。<br>LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作<br>ET模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，或者遇到EAGAIN错误。</p>
<h2 id="epoll的优点："><a href="#epoll的优点：" class="headerlink" title="epoll的优点："></a>epoll的优点：</h2><p><strong>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</strong><br><strong>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</strong><br><strong>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</strong></p>
<p><strong>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</strong></p>
<h2 id="epoll缺点："><a href="#epoll缺点：" class="headerlink" title="epoll缺点："></a>epoll缺点：</h2><p><strong>epoll只能工作在linux下。</strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
